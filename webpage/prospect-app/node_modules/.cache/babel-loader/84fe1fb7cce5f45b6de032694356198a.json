{"ast":null,"code":"import React, { createContext, useContext, useRef, useReducer, useState, useEffect, useLayoutEffect } from 'react';\nimport _objectSpread from '@babel/runtime/helpers/objectSpread2';\nimport { compose, createStore as createStore$1, applyMiddleware } from 'redux';\nimport reduxThunk from 'redux-thunk';\nimport { isDraft, current, Immer, original } from 'immer';\nvar StoreContext = createContext(); // To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\n// subscription callback always has the selector from the latest render commit\n// available, otherwise a store update may happen between render and the effect,\n// which may cause missed updates; we also must ensure the store subscription\n// is created synchronously, otherwise a store update may occur before the\n// subscription is created and an inconsistent state may be observed\n\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n\nfunction createStoreStateHook(Context) {\n  return function useStoreState(mapState, equalityFn) {\n    var store = useContext(Context);\n    var mapStateRef = useRef(mapState);\n    var stateRef = useRef();\n    var mountedRef = useRef(true);\n    var subscriptionMapStateError = useRef();\n\n    var _useReducer = useReducer(function (s) {\n      return s + 1;\n    }, 0),\n        forceRender = _useReducer[1];\n\n    if (subscriptionMapStateError.current || mapStateRef.current !== mapState || stateRef.current === undefined) {\n      try {\n        stateRef.current = mapState(store.getState());\n      } catch (err) {\n        if (process.env.NODE_ENV === 'development') {\n          var errorMessage = \"Error in useStoreState: \" + err.message + \".\";\n\n          if (subscriptionMapStateError.current) {\n            errorMessage += \"\\nMaybe related to:\\n\" + subscriptionMapStateError.current.stack;\n          }\n\n          throw new Error(errorMessage);\n        }\n\n        throw subscriptionMapStateError.current || err;\n      }\n    }\n\n    useIsomorphicLayoutEffect(function () {\n      mapStateRef.current = mapState;\n      subscriptionMapStateError.current = undefined;\n    });\n    useIsomorphicLayoutEffect(function () {\n      var checkMapState = function checkMapState() {\n        try {\n          var newState = mapStateRef.current(store.getState());\n          var isStateEqual = typeof equalityFn === 'function' ? equalityFn(stateRef.current, newState) : stateRef.current === newState;\n\n          if (isStateEqual) {\n            return;\n          }\n\n          stateRef.current = newState;\n        } catch (err) {\n          // see https://github.com/reduxjs/react-redux/issues/1179\n          // There is a possibility mapState will fail due to stale state or\n          // props, therefore we will just track the error and force our\n          // component to update. It should then receive the updated state\n          subscriptionMapStateError.current = err;\n        }\n\n        if (mountedRef.current) {\n          forceRender({});\n        }\n      };\n\n      var unsubscribe = store.subscribe(checkMapState);\n      checkMapState();\n      return function () {\n        mountedRef.current = false;\n        unsubscribe();\n      };\n    }, []);\n    return stateRef.current;\n  };\n}\n\nvar useStoreState = createStoreStateHook(StoreContext);\n\nfunction createStoreActionsHook(Context) {\n  return function useStoreActions(mapActions) {\n    var store = useContext(Context);\n    return mapActions(store.getActions());\n  };\n}\n\nvar useStoreActions = createStoreActionsHook(StoreContext);\n\nfunction createStoreDispatchHook(Context) {\n  return function useStoreDispatch() {\n    var store = useContext(Context);\n    return store.dispatch;\n  };\n}\n\nvar useStoreDispatch = createStoreDispatchHook(StoreContext);\n\nfunction useStore() {\n  return useContext(StoreContext);\n}\n\nfunction createStoreRehydratedHook(Context) {\n  return function useStoreRehydrated() {\n    var store = useContext(Context);\n\n    var _useState = useState(false),\n        rehydrated = _useState[0],\n        setRehydrated = _useState[1];\n\n    useEffect(function () {\n      store.persist.resolveRehydration().then(function () {\n        return setRehydrated(true);\n      });\n    }, []);\n    return rehydrated;\n  };\n}\n\nvar useStoreRehydrated = createStoreRehydratedHook(StoreContext);\n\nfunction createTypedHooks() {\n  return {\n    useStoreActions: useStoreActions,\n    useStoreDispatch: useStoreDispatch,\n    useStoreState: useStoreState,\n    useStoreRehydrated: useStoreRehydrated,\n    useStore: useStore\n  };\n}\n\nvar actionSymbol = '$_a';\nvar actionOnSymbol = '$_aO';\nvar computedSymbol = '$_c';\nvar effectOnSymbol = '$_e';\nvar persistSymbol = '$_p';\nvar reducerSymbol = '$_r';\nvar thunkOnSymbol = '$_tO';\nvar thunkSymbol = '$_t';\n\nvar debug = function debug(state) {\n  if (isDraft(state)) {\n    return current(state);\n  }\n\n  return state;\n};\n\nvar actionOn = function actionOn(targetResolver, fn) {\n  var _ref;\n\n  return _ref = {}, _ref[actionOnSymbol] = true, _ref.fn = fn, _ref.targetResolver = targetResolver, _ref;\n};\n\nvar action = function action(fn) {\n  var _ref2;\n\n  return _ref2 = {}, _ref2[actionSymbol] = true, _ref2.fn = fn, _ref2;\n};\n\nvar defaultStateResolvers = [function (state) {\n  return state;\n}];\n\nvar computed = function computed(fnOrStateResolvers, fn) {\n  var _ref4;\n\n  if (typeof fn === 'function') {\n    var _ref3;\n\n    return _ref3 = {}, _ref3[computedSymbol] = true, _ref3.fn = fn, _ref3.stateResolvers = fnOrStateResolvers, _ref3;\n  }\n\n  return _ref4 = {}, _ref4[computedSymbol] = true, _ref4.fn = fnOrStateResolvers, _ref4.stateResolvers = defaultStateResolvers, _ref4;\n};\n\nfunction unstable_effectOn(dependencyResolvers, fn) {\n  var _ref5;\n\n  return _ref5 = {}, _ref5[effectOnSymbol] = true, _ref5.dependencyResolvers = dependencyResolvers, _ref5.fn = fn, _ref5;\n}\n\nfunction generic(value) {\n  return value;\n}\n\nvar persist = function persist(model, config) {\n  var _objectSpread2;\n\n  return (// if we are not running in a browser context this becomes a no-op\n    typeof window === 'undefined' ? model : _objectSpread(_objectSpread({}, model), {}, (_objectSpread2 = {}, _objectSpread2[persistSymbol] = config, _objectSpread2))\n  );\n};\n\nvar thunkOn = function thunkOn(targetResolver, fn) {\n  var _ref6;\n\n  return _ref6 = {}, _ref6[thunkOnSymbol] = true, _ref6.fn = fn, _ref6.targetResolver = targetResolver, _ref6;\n};\n\nvar thunk = function thunk(fn) {\n  var _ref7;\n\n  return _ref7 = {}, _ref7[thunkSymbol] = true, _ref7.fn = fn, _ref7;\n};\n\nvar reducer = function reducer(fn) {\n  var _ref8;\n\n  return _ref8 = {}, _ref8[reducerSymbol] = true, _ref8.fn = fn, _ref8;\n};\n/**\n * We create our own immer instance to avoid potential issues with autoFreeze\n * becoming default enabled everywhere. We want to disable autofreeze as it\n * does not suit the design of Easy Peasy.\n * https://github.com/immerjs/immer/issues/681#issuecomment-705581111\n */\n\n\nvar easyPeasyImmer;\n\nfunction isPlainObject(obj) {\n  if (typeof obj !== 'object' || obj === null) return false;\n  var proto = obj;\n\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(obj) === proto;\n}\n\nfunction clone(source) {\n  function recursiveClone(current) {\n    var next = Object.keys(current).reduce(function (acc, key) {\n      if (Object.getOwnPropertyDescriptor(current, key).get == null) {\n        acc[key] = current[key];\n      }\n\n      return acc;\n    }, {});\n    Object.keys(next).forEach(function (key) {\n      if (isPlainObject(next[key])) {\n        next[key] = recursiveClone(next[key]);\n      }\n    });\n    return next;\n  }\n\n  return recursiveClone(source);\n}\n\nfunction isPromise(x) {\n  return x != null && typeof x === 'object' && typeof x.then === 'function';\n}\n\nfunction get(path, target) {\n  return path.reduce(function (acc, cur) {\n    return isPlainObject(acc) ? acc[cur] : undefined;\n  }, target);\n}\n\nfunction newify(currentPath, currentState, finalValue) {\n  if (currentPath.length === 0) {\n    return finalValue;\n  }\n\n  var newState = _objectSpread({}, currentState);\n\n  var key = currentPath[0];\n\n  if (currentPath.length === 1) {\n    newState[key] = finalValue;\n  } else {\n    newState[key] = newify(currentPath.slice(1), newState[key], finalValue);\n  }\n\n  return newState;\n}\n\nfunction set(path, target, value) {\n  if (path.length === 0) {\n    if (typeof value === 'object') {\n      Object.keys(target).forEach(function (key) {\n        delete target[key];\n      });\n      Object.keys(value).forEach(function (key) {\n        target[key] = value[key];\n      });\n    }\n\n    return;\n  }\n\n  path.reduce(function (acc, cur, idx) {\n    if (idx + 1 === path.length) {\n      acc[cur] = value;\n    } else {\n      acc[cur] = acc[cur] || {};\n    }\n\n    return acc[cur];\n  }, target);\n}\n\nfunction createSimpleProduce(disableImmer) {\n  if (disableImmer === void 0) {\n    disableImmer = false;\n  }\n\n  return function simpleProduce(path, state, fn) {\n    if (disableImmer) {\n      var _current = get(path, state);\n\n      var next = fn(_current);\n\n      if (_current !== next) {\n        return newify(path, state, next);\n      }\n\n      return state;\n    }\n\n    if (!easyPeasyImmer) {\n      easyPeasyImmer = new Immer({\n        // We need to ensure that we disable proxies if they aren't available\n        // on the environment. Users need to ensure that they use the enableES5\n        // feature of immer.\n        useProxies: typeof Proxy !== 'undefined' && typeof Proxy.revocable !== 'undefined' && typeof Reflect !== 'undefined',\n        // Autofreezing breaks easy-peasy, we need a mixed version of immutability\n        // and mutability in order to apply updates to our computed properties\n        autoFreeze: false\n      });\n    }\n\n    if (path.length === 0) {\n      var _draft = easyPeasyImmer.createDraft(state);\n\n      var _result = fn(_draft);\n\n      if (_result) {\n        return isDraft(_result) ? easyPeasyImmer.finishDraft(_result) : _result;\n      }\n\n      return easyPeasyImmer.finishDraft(_draft);\n    }\n\n    var parentPath = path.slice(0, path.length - 1);\n    var draft = easyPeasyImmer.createDraft(state);\n    var parent = get(parentPath, state);\n    var current = get(path, draft);\n    var result = fn(current);\n\n    if (result) {\n      parent[path[path.length - 1]] = result;\n    }\n\n    return easyPeasyImmer.finishDraft(draft);\n  };\n}\n\nvar pReduce = function pReduce(iterable, reducer, initialValue) {\n  return new Promise(function (resolve, reject) {\n    var iterator = iterable[Symbol.iterator]();\n    var index = 0;\n\n    var next = function next(total) {\n      var element = iterator.next();\n\n      if (element.done) {\n        resolve(total);\n        return;\n      }\n\n      Promise.all([total, element.value]).then(function (value) {\n        return (// eslint-disable-next-line no-plusplus\n          next(reducer(value[0], value[1], index++))\n        );\n      }).catch(function (err) {\n        return reject(err);\n      });\n    };\n\n    next(initialValue);\n  });\n};\n\nvar pSeries = function pSeries(tasks) {\n  var results = [];\n  return pReduce(tasks, function (_, task) {\n    return task().then(function (value) {\n      results.push(value);\n    });\n  }).then(function () {\n    return results;\n  });\n};\n\nfunction areInputsEqual(newInputs, lastInputs) {\n  if (newInputs.length !== lastInputs.length) {\n    return false;\n  }\n\n  for (var i = 0; i < newInputs.length; i += 1) {\n    if (newInputs[i] !== lastInputs[i]) {\n      return false;\n    }\n  }\n\n  return true;\n} // export function memoizeOne(resultFn) {\n//   let lastArgs = [];\n//   let lastResult;\n//   let calledOnce = false;\n//   return function memoized(...args) {\n//     if (calledOnce && areInputsEqual(args, lastArgs)) {\n//       return lastResult;\n//     }\n//     lastResult = resultFn(...args);\n//     calledOnce = true;\n//     lastArgs = args;\n//     return lastResult;\n//   };\n// }\n\n\nfunction useMemoOne( // getResult changes on every call,\ngetResult, // the inputs array changes on every call\ninputs) {\n  // using useState to generate initial value as it is lazy\n  var initial = React.useState(function () {\n    return {\n      inputs: inputs,\n      result: getResult()\n    };\n  })[0];\n  var committed = React.useRef(initial); // persist any uncommitted changes after they have been committed\n\n  var isInputMatch = Boolean(inputs && committed.current.inputs && areInputsEqual(inputs, committed.current.inputs)); // create a new cache if required\n\n  var cache = isInputMatch ? committed.current : {\n    inputs: inputs,\n    result: getResult()\n  }; // commit the cache\n\n  React.useEffect(function () {\n    committed.current = cache;\n  }, [cache]);\n  return cache.result;\n}\n\nfunction createReducer(disableImmer, _aRD, _cR, _cP) {\n  var simpleProduce = createSimpleProduce(disableImmer);\n\n  var runActionReducerAtPath = function runActionReducerAtPath(state, action, actionReducer, path) {\n    return simpleProduce(path, state, function (draft) {\n      return actionReducer(draft, action.payload);\n    });\n  };\n\n  var reducerForActions = function reducerForActions(state, action) {\n    var actionReducer = _aRD[action.type];\n\n    if (actionReducer) {\n      return runActionReducerAtPath(state, action, actionReducer, actionReducer.def.meta.parent);\n    }\n\n    return state;\n  };\n\n  var reducerForCustomReducers = function reducerForCustomReducers(state, action) {\n    return _cR.reduce(function (acc, _ref) {\n      var parentPath = _ref.parentPath,\n          key = _ref.key,\n          reducer = _ref.reducer;\n      return simpleProduce(parentPath, acc, function (draft) {\n        draft[key] = reducer(isDraft(draft[key]) ? original(draft[key]) : draft[key], action);\n        return draft;\n      });\n    }, state);\n  };\n\n  var rootReducer = function rootReducer(state, action) {\n    var stateAfterActions = reducerForActions(state, action);\n    var next = _cR.length > 0 ? reducerForCustomReducers(stateAfterActions, action) : stateAfterActions;\n\n    if (state !== next) {\n      _cP.forEach(function (_ref2) {\n        var parentPath = _ref2.parentPath,\n            bindComputedProperty = _ref2.bindComputedProperty;\n        var parentState = get(parentPath, next);\n        if (parentState != null) bindComputedProperty(parentState, next);\n      });\n    }\n\n    return next;\n  };\n\n  return rootReducer;\n}\n\nvar noopStorage = {\n  getItem: function getItem() {\n    return undefined;\n  },\n  setItem: function setItem() {\n    return undefined;\n  },\n  removeItem: function removeItem() {\n    return undefined;\n  }\n};\n\nvar getBrowerStorage = function getBrowerStorage(storageName) {\n  var storageCache;\n  return function () {\n    if (!storageCache) {\n      try {\n        if (typeof window !== 'undefined' && typeof window[storageName] !== 'undefined') {\n          storageCache = window[storageName];\n        }\n      } catch (_) {// swallow the failure\n      }\n\n      if (!storageCache) {\n        storageCache = noopStorage;\n      }\n    }\n\n    return storageCache;\n  };\n};\n\nvar localStorage = getBrowerStorage('localStorage');\nvar sessionStorage = getBrowerStorage('sessionStorage');\n\nfunction createStorageWrapper(storage, transformers) {\n  if (transformers === void 0) {\n    transformers = [];\n  }\n\n  if (storage == null) {\n    storage = sessionStorage();\n  }\n\n  if (typeof storage === 'string') {\n    if (storage === 'localStorage') {\n      storage = localStorage();\n    } else if (storage === 'sessionStorage') {\n      storage = sessionStorage();\n    } else {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(\"Invalid storage provider\");\n      }\n\n      storage = noopStorage;\n    }\n  }\n\n  var outTransformers = [].concat(transformers).reverse();\n\n  var serialize = function serialize(data) {\n    if (transformers.length > 0 && data != null && typeof data === 'object') {\n      Object.keys(data).forEach(function (key) {\n        data[key] = transformers.reduce(function (acc, cur) {\n          return cur.in(acc, key);\n        }, data[key]);\n      });\n    }\n\n    return storage === localStorage() || storage === sessionStorage() ? JSON.stringify({\n      data: data\n    }) : data;\n  };\n\n  var deserialize = function deserialize(data) {\n    var result = storage === localStorage() || storage === sessionStorage() ? JSON.parse(data).data : data;\n\n    if (outTransformers.length > 0 && result != null && typeof result === 'object') {\n      Object.keys(result).forEach(function (key) {\n        result[key] = outTransformers.reduce(function (acc, cur) {\n          return cur.out(acc, key);\n        }, result[key]);\n      });\n    }\n\n    return result;\n  };\n\n  var isAsync = isPromise(storage.getItem('_'));\n  return {\n    getItem: function getItem(key) {\n      if (isAsync) {\n        return storage.getItem(key).then(function (wrapped) {\n          return wrapped != null ? deserialize(wrapped) : undefined;\n        });\n      }\n\n      var wrapped = storage.getItem(key);\n      return wrapped != null ? deserialize(wrapped) : undefined;\n    },\n    setItem: function setItem(key, data) {\n      return storage.setItem(key, serialize(data));\n    },\n    removeItem: function removeItem(key) {\n      return storage.removeItem(key);\n    }\n  };\n}\n\nfunction extractPersistConfig(path, persistdef) {\n  if (persistdef === void 0) {\n    persistdef = {};\n  }\n\n  return {\n    path: path,\n    config: {\n      allow: persistdef.allow || [],\n      deny: persistdef.deny || [],\n      mergeStrategy: persistdef.mergeStrategy || 'mergeDeep',\n      storage: createStorageWrapper(persistdef.storage, persistdef.transformers)\n    }\n  };\n}\n\nfunction resolvePersistTargets(target, allow, deny) {\n  var targets = Object.keys(target);\n\n  if (allow.length > 0) {\n    targets = targets.reduce(function (acc, cur) {\n      if (allow.findIndex(function (x) {\n        return x === cur;\n      }) !== -1) {\n        return [].concat(acc, [cur]);\n      }\n\n      return acc;\n    }, []);\n  }\n\n  if (deny.length > 0) {\n    targets = targets.reduce(function (acc, cur) {\n      if (deny.findIndex(function (x) {\n        return x === cur;\n      }) !== -1) {\n        return acc;\n      }\n\n      return [].concat(acc, [cur]);\n    }, []);\n  }\n\n  return targets;\n}\n\nfunction createPersistenceClearer(persistKey, _r) {\n  return function () {\n    if (_r._i._persistenceConfig.length === 0) {\n      return Promise.resolve();\n    }\n\n    return pSeries(_r._i._persistenceConfig.map(function (_ref) {\n      var path = _ref.path,\n          config = _ref.config;\n      return function () {\n        return Promise.resolve(config.storage.removeItem(persistKey(path)));\n      };\n    }));\n  };\n}\n\nfunction createPersistor(persistKey, _r) {\n  var persistPromise = Promise.resolve();\n  var isPersisting = false;\n  var nextPersistOperation;\n  var timingMethod = typeof window === 'undefined' ? function (fn) {\n    return fn();\n  } : window.requestIdleCallback != null ? window.requestIdleCallback : window.requestAnimationFrame;\n\n  var persist = function persist(nextState) {\n    if (_r._i._persistenceConfig.length === 0) {\n      return;\n    }\n\n    var operation = function operation() {\n      isPersisting = true;\n      persistPromise = new Promise(function (resolve) {\n        timingMethod(function () {\n          pSeries(_r._i._persistenceConfig.map(function (_ref2) {\n            var path = _ref2.path,\n                config = _ref2.config;\n            return function () {\n              var storage = config.storage,\n                  allow = config.allow,\n                  deny = config.deny;\n              var persistRootState = clone(get(path, nextState));\n              var persistTargets = resolvePersistTargets(persistRootState, allow, deny);\n              var stateToPersist = {};\n              persistTargets.map(function (key) {\n                var targetPath = [].concat(path, [key]);\n                var rawValue = get(targetPath, nextState);\n                var value = isPlainObject(rawValue) ? clone(rawValue) : rawValue;\n                stateToPersist[key] = value;\n              });\n              return Promise.resolve(storage.setItem(persistKey(path), stateToPersist));\n            };\n          })).finally(function () {\n            isPersisting = false;\n\n            if (nextPersistOperation) {\n              var next = nextPersistOperation;\n              nextPersistOperation = null;\n              next();\n            } else {\n              resolve();\n            }\n          });\n        });\n      });\n    };\n\n    if (isPersisting) {\n      nextPersistOperation = operation;\n    } else {\n      operation();\n    }\n  };\n\n  return {\n    persist: persist,\n    clear: createPersistenceClearer(persistKey, _r),\n    flush: function flush() {\n      if (nextPersistOperation) {\n        nextPersistOperation();\n      }\n\n      return persistPromise;\n    }\n  };\n}\n\nfunction createPersistMiddleware(persistor, _r) {\n  return function (_ref3) {\n    var getState = _ref3.getState;\n    return function (next) {\n      return function (action) {\n        var state = next(action);\n\n        if (action && action.type !== '@action.ePRS' && _r._i._persistenceConfig.length > 0) {\n          persistor.persist(getState());\n        }\n\n        return state;\n      };\n    };\n  };\n}\n\nfunction rehydrateStateFromPersistIfNeeded(persistKey, replaceState, _r, root) {\n  if (_r._i._persistenceConfig.length === 0) {\n    return Promise.resolve();\n  }\n\n  var state = clone(_r._i._dS);\n  var rehydrating = false;\n  return pSeries(_r._i._persistenceConfig.map(function (persistInstance) {\n    return function () {\n      var path = persistInstance.path,\n          config = persistInstance.config;\n      var mergeStrategy = config.mergeStrategy,\n          storage = config.storage;\n\n      if (root && (path.length < 1 || path[0] !== root)) {\n        return Promise.resolve();\n      }\n\n      var hasDataModelChanged = function hasDataModelChanged(dataModel, rehydratingModelData) {\n        return dataModel != null && rehydratingModelData != null && (typeof dataModel !== typeof rehydratingModelData || Array.isArray(dataModel) && !Array.isArray(rehydratingModelData));\n      };\n\n      var applyRehydrationStrategy = function applyRehydrationStrategy(persistedState) {\n        if (mergeStrategy === 'overwrite') {\n          set(path, state, persistedState);\n        } else if (mergeStrategy === 'mergeShallow') {\n          var targetState = get(path, state);\n          Object.keys(persistedState).forEach(function (key) {\n            if (hasDataModelChanged(targetState[key], persistedState[key])) ;else {\n              targetState[key] = persistedState[key];\n            }\n          });\n        } else if (mergeStrategy === 'mergeDeep') {\n          var _targetState = get(path, state);\n\n          var setAt = function setAt(currentTargetState, currentPersistedState) {\n            Object.keys(currentPersistedState).forEach(function (key) {\n              if (hasDataModelChanged(currentTargetState[key], currentPersistedState[key])) ;else if (isPlainObject(currentPersistedState[key])) {\n                currentTargetState[key] = currentTargetState[key] || {};\n                setAt(currentTargetState[key], currentPersistedState[key]);\n              } else {\n                currentTargetState[key] = currentPersistedState[key];\n              }\n            });\n          };\n\n          setAt(_targetState, persistedState);\n        }\n      };\n\n      var rehydate = function rehydate(persistedState) {\n        if (persistedState != null) {\n          applyRehydrationStrategy(persistedState);\n          rehydrating = true;\n        }\n      };\n\n      var getItemResult = storage.getItem(persistKey(path));\n\n      if (isPromise(getItemResult)) {\n        return getItemResult.then(rehydate);\n      }\n\n      return Promise.resolve(rehydate(getItemResult));\n    };\n  })).then(function () {\n    if (rehydrating) {\n      replaceState(state);\n    }\n  });\n}\n\nfunction createActionCreator(def, _r) {\n  function actionCreator(payload) {\n    var action = {\n      type: def.meta.type,\n      payload: payload\n    };\n\n    if (def[actionOnSymbol] && def.meta.resolvedTargets) {\n      payload.resolvedTargets = [].concat(def.meta.resolvedTargets);\n    }\n\n    return _r.dispatch(action);\n  } // We bind the types to the creator for easy reference by consumers\n\n\n  actionCreator.type = def.meta.type;\n  return actionCreator;\n}\n\nfunction createThunkHandler(def, _r, injections, _aC) {\n  return function (payload, fail) {\n    var helpers = {\n      dispatch: _r.dispatch,\n      fail: fail,\n      getState: function getState() {\n        return get(def.meta.parent, _r.getState());\n      },\n      getStoreActions: function getStoreActions() {\n        return _aC;\n      },\n      getStoreState: _r.getState,\n      injections: injections,\n      meta: {\n        key: def.meta.actionName,\n        parent: def.meta.parent,\n        path: def.meta.path\n      }\n    };\n\n    if (def[thunkOnSymbol] && def.meta.resolvedTargets) {\n      payload.resolvedTargets = [].concat(def.meta.resolvedTargets);\n    }\n\n    return def.fn(get(def.meta.parent, _aC), payload, helpers);\n  };\n}\n\nvar logThunkEventListenerError = function logThunkEventListenerError(type, err) {\n  // eslint-disable-next-line no-console\n  console.log(\"Error in \" + type); // eslint-disable-next-line no-console\n\n  console.log(err);\n};\n\nvar handleEventDispatchErrors$1 = function handleEventDispatchErrors(type, dispatcher) {\n  return function () {\n    try {\n      var result = dispatcher.apply(void 0, arguments);\n\n      if (isPromise(result)) {\n        result.catch(function (err) {\n          logThunkEventListenerError(type, err);\n        });\n      }\n    } catch (err) {\n      logThunkEventListenerError(type, err);\n    }\n  };\n};\n\nfunction createThunkActionsCreator(def, _r) {\n  var actionCreator = function actionCreator(payload) {\n    var dispatchStart = handleEventDispatchErrors$1(def.meta.startType, function () {\n      return _r.dispatch({\n        type: def.meta.startType,\n        payload: payload\n      });\n    });\n    var dispatchFail = handleEventDispatchErrors$1(def.meta.failType, function (err) {\n      return _r.dispatch({\n        type: def.meta.failType,\n        payload: payload,\n        error: err\n      });\n    });\n    var dispatchSuccess = handleEventDispatchErrors$1(def.meta.successType, function (result) {\n      return _r.dispatch({\n        type: def.meta.successType,\n        payload: payload,\n        result: result\n      });\n    });\n    dispatchStart();\n    var failure = null;\n\n    var fail = function fail(_failure) {\n      failure = _failure;\n    };\n\n    var result = _r.dispatch(function () {\n      return def.thunkHandler(payload, fail);\n    });\n\n    if (isPromise(result)) {\n      return result.then(function (resolved) {\n        if (failure) {\n          dispatchFail(failure);\n        } else {\n          dispatchSuccess(resolved);\n        }\n\n        return resolved;\n      });\n    }\n\n    if (failure) {\n      dispatchFail(failure);\n    } else {\n      dispatchSuccess(result);\n    }\n\n    return result;\n  };\n\n  actionCreator.type = def.meta.type;\n  actionCreator.successType = def.meta.successType;\n  actionCreator.failType = def.meta.failType;\n  actionCreator.startType = def.meta.startType;\n  return actionCreator;\n}\n\nfunction createListenerMiddleware(_r) {\n  return function () {\n    return function (next) {\n      return function (action) {\n        var result = next(action);\n\n        if (action && _r._i._lAM[action.type] && _r._i._lAM[action.type].length > 0) {\n          var sourceAction = _r._i._aCD[action.type];\n\n          _r._i._lAM[action.type].forEach(function (actionCreator) {\n            actionCreator({\n              type: sourceAction ? sourceAction.def.meta.type : action.type,\n              payload: action.payload,\n              error: action.error,\n              result: action.result\n            });\n          });\n        }\n\n        return result;\n      };\n    };\n  };\n}\n\nfunction bindListenerdefs(listenerdefs, _aC, _aCD, _lAM) {\n  listenerdefs.forEach(function (def) {\n    var targets = def.targetResolver(get(def.meta.parent, _aC), _aC);\n    var targetTypes = (Array.isArray(targets) ? targets : [targets]).reduce(function (acc, target) {\n      if (typeof target === 'function' && target.def.meta.type && _aCD[target.def.meta.type]) {\n        if (target.def.meta.successType) {\n          acc.push(target.def.meta.successType);\n        } else {\n          acc.push(target.def.meta.type);\n        }\n      } else if (typeof target === 'string') {\n        acc.push(target);\n      }\n\n      return acc;\n    }, []);\n    def.meta.resolvedTargets = targetTypes;\n    targetTypes.forEach(function (targetType) {\n      var listenerReg = _lAM[targetType] || [];\n      listenerReg.push(_aCD[def.meta.type]);\n      _lAM[targetType] = listenerReg;\n    });\n  });\n}\n\nfunction createComputedPropertyBinder(parentPath, key, def, _r) {\n  var runOnce = false;\n  var prevInputs = [];\n  var prevValue;\n  return function createComputedProperty(parentState, storeState) {\n    Object.defineProperty(parentState, key, {\n      configurable: true,\n      enumerable: true,\n      get: function get() {\n        var inputs = def.stateResolvers.map(function (resolver) {\n          return resolver(parentState, storeState);\n        });\n\n        if (runOnce && (areInputsEqual(prevInputs, inputs) || _r._i._cS.isInReducer && new Error().stack.match(/shallowCopy/gi) !== null)) {\n          // We don't want computed properties resolved every time an action\n          // is handled by the reducer. They need to remain lazy, only being\n          // computed when used by a component or getState call.\n          return prevValue;\n        }\n\n        prevInputs = inputs;\n        prevValue = def.fn.apply(def, inputs);\n        runOnce = true;\n        return prevValue;\n      }\n    });\n  };\n}\n\nfunction createComputedPropertiesMiddleware(_r) {\n  return function () {\n    return function (next) {\n      return function (action) {\n        _r._i._cS.isInReducer = true;\n        var result = next(action);\n        _r._i._cS.isInReducer = false;\n        return result;\n      };\n    };\n  };\n}\n\nfunction createEffectsMiddleware(_r) {\n  return function (store) {\n    return function (next) {\n      return function (action) {\n        if (_r._i._e.length === 0) {\n          return next(action);\n        }\n\n        var prevState = store.getState();\n        var result = next(action);\n        var nextState = store.getState();\n\n        _r._i._e.forEach(function (def) {\n          var prevLocal = get(def.meta.parent, prevState);\n          var nextLocal = get(def.meta.parent, nextState);\n\n          if (prevLocal !== nextLocal) {\n            var prevDependencies = def.dependencyResolvers.map(function (resolver) {\n              return resolver(prevLocal);\n            });\n            var nextDependencies = def.dependencyResolvers.map(function (resolver) {\n              return resolver(nextLocal);\n            });\n            var hasChanged = prevDependencies.some(function (dependency, idx) {\n              return dependency !== nextDependencies[idx];\n            });\n\n            if (hasChanged) {\n              def.actionCreator(prevDependencies, nextDependencies, action);\n            }\n          }\n        });\n\n        return result;\n      };\n    };\n  };\n}\n\nvar logEffectError = function logEffectError(err) {\n  // As users can't get a handle on effects we need to report the error\n  // eslint-disable-next-line no-console\n  console.log(err);\n};\n\nfunction createEffectHandler(def, _r, injections, _aC) {\n  var actions = get(def.meta.parent, _aC);\n  var dispose;\n  return function (change) {\n    var helpers = {\n      dispatch: _r.dispatch,\n      getState: function getState() {\n        return get(def.meta.parent, _r.getState());\n      },\n      getStoreActions: function getStoreActions() {\n        return _aC;\n      },\n      getStoreState: _r.getState,\n      injections: injections,\n      meta: {\n        key: def.meta.actionName,\n        parent: def.meta.parent,\n        path: def.meta.path\n      }\n    };\n\n    if (dispose !== undefined) {\n      var disposeResult = dispose();\n      dispose = undefined;\n\n      if (isPromise(disposeResult)) {\n        disposeResult.catch(logEffectError);\n      }\n    }\n\n    var effectResult = def.fn(actions, change, helpers);\n\n    if (isPromise(effectResult)) {\n      return effectResult.then(function (resolved) {\n        if (typeof resolved === 'function') {\n          if (process.env.NODE_ENV !== 'production') {\n            // Dispose functions are not allowed to be resolved asynchronously.\n            // Doing so would provide inconsistent behaviour around their execution.\n            // eslint-disable-next-line no-console\n            console.warn('[easy-peasy] Effect is asynchronously resolving a dispose fn.');\n          }\n        }\n      });\n    }\n\n    if (typeof effectResult === 'function') {\n      dispose = effectResult;\n    }\n\n    return undefined;\n  };\n}\n\nvar logEffectEventListenerError = function logEffectEventListenerError(type, err) {\n  // eslint-disable-next-line no-console\n  console.log(\"Error in \" + type); // eslint-disable-next-line no-console\n\n  console.log(err);\n};\n\nvar handleEventDispatchErrors = function handleEventDispatchErrors(type, dispatcher) {\n  return function () {\n    try {\n      var result = dispatcher.apply(void 0, arguments);\n\n      if (isPromise(result)) {\n        result.catch(function (err) {\n          logEffectEventListenerError(type, err);\n        });\n      }\n    } catch (err) {\n      logEffectEventListenerError(type, err);\n    }\n  };\n};\n\nfunction createEffectActionsCreator(def, _r, effectHandler) {\n  var actionCreator = function actionCreator(previousDependencies, nextDependencies, action) {\n    var change = {\n      prev: previousDependencies,\n      current: nextDependencies,\n      action: action\n    };\n    var dispatchStart = handleEventDispatchErrors(def.meta.startType, function () {\n      return _r.dispatch({\n        type: def.meta.startType,\n        change: change\n      });\n    });\n    var dispatchSuccess = handleEventDispatchErrors(def.meta.successType, function () {\n      return _r.dispatch({\n        type: def.meta.successType,\n        change: change\n      });\n    });\n    dispatchStart();\n\n    try {\n      var result = _r.dispatch(function () {\n        return effectHandler(change);\n      });\n\n      if (isPromise(result)) {\n        return result.then(function (resolved) {\n          dispatchSuccess(resolved);\n          return resolved;\n        }, logEffectError);\n      }\n\n      dispatchSuccess(result);\n      return result;\n    } catch (err) {\n      logEffectError(err);\n    }\n  };\n\n  actionCreator.type = def.meta.type;\n  actionCreator.startType = def.meta.startType;\n  actionCreator.successType = def.meta.successType;\n  actionCreator.failType = def.meta.failType;\n  return actionCreator;\n}\n\nfunction extractDataFromModel(model, initialState, injections, _r) {\n  var _dS = initialState;\n  var _aCD = {};\n  var _aC = {};\n  var _aRD = {};\n  var actionThunks = {};\n  var _cP = [];\n  var _cR = [];\n  var _e = [];\n  var _lAC = {};\n  var _lAM = {};\n  var listenerdefs = [];\n  var _persistenceConfig = [];\n  var _cS = {\n    isInReducer: false\n  };\n\n  var recursiveExtractFromModel = function recursiveExtractFromModel(current, parentPath) {\n    return Object.keys(current).forEach(function (key) {\n      var value = current[key];\n      var path = [].concat(parentPath, [key]);\n      var meta = {\n        parent: parentPath,\n        path: path,\n        key: key\n      };\n\n      var handleValueAsState = function handleValueAsState() {\n        var initialParentRef = get(parentPath, initialState);\n\n        if (initialParentRef && key in initialParentRef) {\n          set(path, _dS, initialParentRef[key]);\n        } else {\n          set(path, _dS, value);\n        }\n      };\n\n      if (key === persistSymbol) {\n        _persistenceConfig.push(extractPersistConfig(parentPath, value));\n\n        return;\n      }\n\n      if (value != null && typeof value === 'object') {\n        if (value[actionSymbol] || value[actionOnSymbol]) {\n          var def = _objectSpread({}, value); // Determine the category of the action\n\n\n          var category = def[actionSymbol] ? '@action' : '@actionOn'; // Establish the meta data describing the action\n\n          def.meta = {\n            actionName: meta.key,\n            category: category,\n            type: category + \".\" + meta.path.join('.'),\n            parent: meta.parent,\n            path: meta.path\n          }; // Create the \"action creator\" function\n\n          def.actionCreator = createActionCreator(def, _r); // Create a bidirectional relationship of the def/actionCreator\n\n          def.actionCreator.def = def; // Create a bidirectional relationship of the def/reducer\n\n          def.fn.def = def; // Add the action creator to lookup map\n\n          _aCD[def.meta.type] = def.actionCreator; // Add the reducer to lookup map\n\n          _aRD[def.meta.type] = def.fn; // We don't want to expose the internal action to consumers\n\n          if (meta.key !== 'ePRS') {\n            // Set the action creator in the \"actions\" object tree for\n            // either the listeners object tree, or the standard actions/thunks\n            // object tree\n            if (def[actionOnSymbol]) {\n              listenerdefs.push(def);\n              set(path, _lAC, def.actionCreator);\n            } else {\n              set(path, _aC, def.actionCreator);\n            }\n          }\n        } else if (value[thunkSymbol] || value[thunkOnSymbol]) {\n          var _def = _objectSpread({}, value); // Determine the category of the thunk\n\n\n          var _category = _def[thunkSymbol] ? '@thunk' : '@thunkOn'; // Establish the meta data describing the thunk\n\n\n          var type = _category + \".\" + meta.path.join('.');\n          _def.meta = {\n            actionName: meta.key,\n            parent: meta.parent,\n            path: meta.path,\n            type: type,\n            startType: type + \"(start)\",\n            successType: type + \"(success)\",\n            failType: type + \"(fail)\"\n          }; // Create the function that will handle, i.e. be executed, when\n          // the thunk action is created/dispatched\n\n          _def.thunkHandler = createThunkHandler(_def, _r, injections, _aC); // Register the thunk handler\n\n          set(path, actionThunks, _def.thunkHandler); // Create the \"action creator\" function\n\n          _def.actionCreator = createThunkActionsCreator(_def, _r); // Create a bidirectional relationship of the def/actionCreator\n\n          _def.actionCreator.def = _def; // Register the action creator within the lookup map\n\n          _aCD[_def.meta.type] = _def.actionCreator; // Set the action creator in the \"actions\" object tree for\n          // either the listeners object tree, or the standard actions/thunks\n          // object tree\n\n          if (_def[thunkOnSymbol]) {\n            listenerdefs.push(_def);\n            set(path, _lAC, _def.actionCreator);\n          } else {\n            set(path, _aC, _def.actionCreator);\n          }\n        } else if (value[computedSymbol]) {\n          var parent = get(parentPath, _dS);\n          var bindComputedProperty = createComputedPropertyBinder(parentPath, key, value, _r);\n          bindComputedProperty(parent, _dS);\n\n          _cP.push({\n            key: key,\n            parentPath: parentPath,\n            bindComputedProperty: bindComputedProperty\n          });\n        } else if (value[reducerSymbol]) {\n          _cR.push({\n            key: key,\n            parentPath: parentPath,\n            reducer: value.fn\n          });\n        } else if (value[effectOnSymbol]) {\n          var _def2 = _objectSpread({}, value); // Establish the meta data describing the effect\n\n\n          var _type = \"@effectOn.\" + meta.path.join('.');\n\n          _def2.meta = {\n            type: _type,\n            actionName: meta.key,\n            parent: meta.parent,\n            path: meta.path,\n            startType: _type + \"(start)\",\n            successType: _type + \"(success)\",\n            failType: _type + \"(fail)\"\n          };\n          var effectHandler = createEffectHandler(_def2, _r, injections, _aC);\n          var actionCreator = createEffectActionsCreator(_def2, _r, effectHandler);\n          _def2.actionCreator = actionCreator;\n\n          _e.push(_def2);\n        } else if (isPlainObject(value)) {\n          var existing = get(path, _dS);\n\n          if (existing == null) {\n            set(path, _dS, {});\n          }\n\n          recursiveExtractFromModel(value, path);\n        } else {\n          handleValueAsState();\n        }\n      } else {\n        handleValueAsState();\n      }\n    });\n  };\n\n  _persistenceConfig = _persistenceConfig.sort(function (a, b) {\n    var aPath = a.path.join('.');\n    var bPath = b.path.join('.');\n\n    if (aPath < bPath) {\n      return -1;\n    }\n\n    if (aPath > bPath) {\n      return 1;\n    }\n\n    return 0;\n  });\n  recursiveExtractFromModel(model, []);\n  bindListenerdefs(listenerdefs, _aC, _aCD, _lAM);\n  return {\n    _aCD: _aCD,\n    _aC: _aC,\n    _aRD: _aRD,\n    _cP: _cP,\n    _cR: _cR,\n    _cS: _cS,\n    _dS: _dS,\n    _e: _e,\n    _lAC: _lAC,\n    _lAM: _lAM,\n    _persistenceConfig: _persistenceConfig\n  };\n}\n\nfunction createStore(model, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var modelClone = clone(model);\n  var _options = options,\n      compose$1 = _options.compose,\n      _options$devTools = _options.devTools,\n      devTools = _options$devTools === void 0 ? process.env.NODE_ENV !== 'production' : _options$devTools,\n      _options$disableImmer = _options.disableImmer,\n      disableImmer = _options$disableImmer === void 0 ? false : _options$disableImmer,\n      _options$enhancers = _options.enhancers,\n      enhancers = _options$enhancers === void 0 ? [] : _options$enhancers,\n      _options$initialState = _options.initialState,\n      initialState = _options$initialState === void 0 ? {} : _options$initialState,\n      _options$injections = _options.injections,\n      injections = _options$injections === void 0 ? {} : _options$injections,\n      _options$middleware = _options.middleware,\n      middleware = _options$middleware === void 0 ? [] : _options$middleware,\n      _options$mockActions = _options.mockActions,\n      mockActions = _options$mockActions === void 0 ? false : _options$mockActions,\n      _options$name = _options.name,\n      storeName = _options$name === void 0 ? \"EasyPeasyStore\" : _options$name,\n      _options$version = _options.version,\n      version = _options$version === void 0 ? 0 : _options$version,\n      _options$reducerEnhan = _options.reducerEnhancer,\n      reducerEnhancer = _options$reducerEnhan === void 0 ? function (rootReducer) {\n    return rootReducer;\n  } : _options$reducerEnhan;\n\n  var bindReplaceState = function bindReplaceState(modelDef) {\n    return _objectSpread(_objectSpread({}, modelDef), {}, {\n      ePRS: action(function (_, payload) {\n        return payload;\n      })\n    });\n  };\n\n  var _r = {};\n  var modeldef = bindReplaceState(modelClone);\n  var mockedActions = [];\n\n  var persistKey = function persistKey(targetPath) {\n    return \"[\" + storeName + \"][\" + version + \"]\" + (targetPath.length > 0 ? \"[\" + targetPath.join('.') + \"]\" : '');\n  };\n\n  var persistor = createPersistor(persistKey, _r);\n  var persistMiddleware = createPersistMiddleware(persistor, _r);\n\n  var replaceState = function replaceState(nextState) {\n    return _r._i._aCD['@action.ePRS'](nextState);\n  };\n\n  var bindStoreInternals = function bindStoreInternals(state) {\n    if (state === void 0) {\n      state = {};\n    }\n\n    var data = extractDataFromModel(modeldef, state, injections, _r);\n    _r._i = _objectSpread(_objectSpread({}, data), {}, {\n      reducer: reducerEnhancer(createReducer(disableImmer, data._aRD, data._cR, data._cP))\n    });\n  };\n\n  var mockActionsMiddleware = function mockActionsMiddleware() {\n    return function () {\n      return function (action) {\n        if (action != null) {\n          mockedActions.push(action);\n        }\n\n        return undefined;\n      };\n    };\n  };\n\n  var composeEnhancers = compose$1 || (devTools && typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({\n    name: storeName\n  }) : compose);\n  bindStoreInternals(initialState);\n  var easyPeasyMiddleware = [createComputedPropertiesMiddleware(_r)].concat(middleware, [reduxThunk, createListenerMiddleware(_r), createEffectsMiddleware(_r), persistMiddleware]);\n\n  if (mockActions) {\n    easyPeasyMiddleware.push(mockActionsMiddleware);\n  }\n\n  var store = createStore$1(_r._i.reducer, _r._i._dS, composeEnhancers.apply(void 0, [applyMiddleware.apply(void 0, easyPeasyMiddleware)].concat(enhancers)));\n  store.subscribe(function () {\n    _r._i._cS.isInReducer = false;\n  });\n  _r.dispatch = store.dispatch;\n  _r.getState = store.getState;\n\n  var bindActionCreators = function bindActionCreators() {\n    Object.keys(store.dispatch).forEach(function (actionsKey) {\n      delete store.dispatch[actionsKey];\n    });\n    Object.keys(_r._i._aC).forEach(function (key) {\n      store.dispatch[key] = _r._i._aC[key];\n    });\n  };\n\n  bindActionCreators();\n\n  var rebindStore = function rebindStore(removeKey) {\n    var currentState = store.getState();\n\n    if (removeKey) {\n      delete currentState[removeKey];\n    }\n\n    bindStoreInternals(currentState);\n    store.replaceReducer(_r._i.reducer);\n    replaceState(_r._i._dS);\n    bindActionCreators();\n  };\n\n  var _resolveRehydration = rehydrateStateFromPersistIfNeeded(persistKey, replaceState, _r);\n\n  return Object.assign(store, {\n    addModel: function addModel(key, modelForKey) {\n      if (modeldef[key] && process.env.NODE_ENV !== 'production') {\n        store.removeModel(key);\n      }\n\n      modeldef[key] = modelForKey;\n      rebindStore(); // There may have been persisted state for a dynamic model. We should try\n      // and rehydrate the specifc node\n\n      var addModelRehydration = rehydrateStateFromPersistIfNeeded(persistKey, replaceState, _r, key);\n      return {\n        resolveRehydration: function resolveRehydration() {\n          return addModelRehydration;\n        }\n      };\n    },\n    clearMockedActions: function clearMockedActions() {\n      mockedActions = [];\n    },\n    getActions: function getActions() {\n      return _r._i._aC;\n    },\n    getListeners: function getListeners() {\n      return _r._i._lAC;\n    },\n    getMockedActions: function getMockedActions() {\n      return [].concat(mockedActions);\n    },\n    persist: {\n      clear: persistor.clear,\n      flush: persistor.flush,\n      resolveRehydration: function resolveRehydration() {\n        return _resolveRehydration;\n      }\n    },\n    reconfigure: function reconfigure(newModel) {\n      modeldef = bindReplaceState(newModel);\n      rebindStore();\n    },\n    removeModel: function removeModel(key) {\n      if (!modeldef[key]) {\n        return;\n      }\n\n      delete modeldef[key];\n      rebindStore(key);\n    }\n  });\n}\n\nfunction createContextStore(model, config) {\n  if (config === void 0) {\n    config = {};\n  } // We create a mutable injections reference to allow updating it\n\n\n  var _config = config,\n      _config$injections = _config.injections,\n      mutableInjections = _config$injections === void 0 ? {} : _config$injections;\n  var StoreContext = createContext();\n\n  function Provider(_ref) {\n    var children = _ref.children,\n        runtimeModel = _ref.runtimeModel,\n        injections = _ref.injections; // If the user provided injections we need to ensure our mutable ref\n    // is up to date. We could consider doing a shallow compare here?\n\n    if (injections != null) {\n      var nextInjections = typeof injections === 'function' ? injections(mutableInjections) : injections;\n      var nextKeys = Object.keys(nextInjections);\n      var removeKeys = Object.keys(mutableInjections).filter(function (k) {\n        return !nextKeys.includes(k);\n      });\n      removeKeys.forEach(function (k) {\n        delete mutableInjections[k];\n      });\n      Object.assign(mutableInjections, nextInjections);\n    }\n\n    var store = useMemoOne(function () {\n      return createStore(typeof model === 'function' ? model(runtimeModel) : model, _objectSpread(_objectSpread({}, config), {}, {\n        originalInjections: mutableInjections\n      }));\n    }, []);\n    return /*#__PURE__*/React.createElement(StoreContext.Provider, {\n      value: store\n    }, children);\n  }\n\n  function useStore() {\n    return useContext(StoreContext);\n  }\n\n  return {\n    Provider: Provider,\n    useStore: useStore,\n    useStoreState: createStoreStateHook(StoreContext),\n    useStoreActions: createStoreActionsHook(StoreContext),\n    useStoreDispatch: createStoreDispatchHook(StoreContext),\n    useStoreRehydrated: createStoreRehydratedHook(StoreContext)\n  };\n}\n/**\n * This file has been copied from redux-persist.\n * The intention being to support as much of the redux-persist API as possible.\n */\n\n\nfunction createTransform(inbound, outbound, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var whitelist = config.whitelist || null;\n  var blacklist = config.blacklist || null;\n\n  function whitelistBlacklistCheck(key) {\n    if (whitelist && whitelist.indexOf(key) === -1) return true;\n    if (blacklist && blacklist.indexOf(key) !== -1) return true;\n    return false;\n  }\n\n  return {\n    in: function _in(data, key, fullState) {\n      return !whitelistBlacklistCheck(key) && inbound ? inbound(data, key, fullState) : data;\n    },\n    out: function out(data, key, fullState) {\n      return !whitelistBlacklistCheck(key) && outbound ? outbound(data, key, fullState) : data;\n    }\n  };\n}\n/* eslint-disable react/prop-types */\n\n\nfunction StoreProvider(_ref) {\n  var children = _ref.children,\n      store = _ref.store;\n  return /*#__PURE__*/React.createElement(StoreContext.Provider, {\n    value: store\n  }, children);\n}\n\nfunction useLocalStore(modelCreator, dependencies, configCreator) {\n  if (dependencies === void 0) {\n    dependencies = [];\n  }\n\n  var storeRef = useRef();\n  var configRef = useRef();\n  var store = useMemoOne(function () {\n    var previousState = storeRef.current != null ? storeRef.current.getState() : undefined;\n    var config = configCreator != null ? configCreator(previousState, configRef.current) : undefined;\n\n    var _store = createStore(modelCreator(previousState), config);\n\n    configRef.current = config;\n    storeRef.current = _store;\n    return _store;\n  }, dependencies);\n\n  var _useState = useState(function () {\n    return store.getState();\n  }),\n      currentState = _useState[0],\n      setCurrentState = _useState[1];\n\n  useEffect(function () {\n    return store.subscribe(function () {\n      var nextState = store.getState();\n\n      if (currentState !== nextState) {\n        setCurrentState(nextState);\n      }\n    });\n  }, [store]);\n  return [currentState, store.getActions(), store];\n}\n\nexport { StoreProvider, action, actionOn, computed, createContextStore, createStore, createStoreActionsHook, createStoreDispatchHook, createStoreRehydratedHook, createStoreStateHook, createTransform, createTypedHooks, debug, generic, persist, reducer, thunk, thunkOn, unstable_effectOn, useLocalStore, useStore, useStoreActions, useStoreDispatch, useStoreRehydrated, useStoreState };","map":{"version":3,"sources":["../src/context.js","../src/hooks.js","../src/constants.js","../src/helpers.js","../src/lib.js","../src/create-reducer.js","../src/persistence.js","../src/actions.js","../src/thunks.js","../src/listeners.js","../src/computed-properties.js","../src/effects.js","../src/extract-data-from-model.js","../src/create-store.js","../src/create-context-store.js","../src/create-transform.js","../src/provider.js","../src/use-local-store.js"],"names":["StoreContext","createContext","useIsomorphicLayoutEffect","store","useContext","mapStateRef","useRef","stateRef","mountedRef","subscriptionMapStateError","forceRender","useReducer","s","mapState","process","errorMessage","err","checkMapState","newState","isStateEqual","equalityFn","unsubscribe","useStoreState","createStoreStateHook","mapActions","useStoreActions","createStoreActionsHook","useStoreDispatch","createStoreDispatchHook","rehydrated","setRehydrated","useState","useEffect","useStoreRehydrated","createStoreRehydratedHook","useStore","actionSymbol","actionOnSymbol","computedSymbol","effectOnSymbol","persistSymbol","reducerSymbol","thunkOnSymbol","thunkSymbol","debug","isDraft","current","actionOn","action","defaultStateResolvers","computed","persist","thunkOn","thunk","reducer","obj","proto","Object","next","acc","isPlainObject","recursiveClone","x","currentPath","key","newify","path","target","value","idx","disableImmer","get","fn","easyPeasyImmer","useProxies","Proxy","autoFreeze","draft","result","parentPath","parent","pReduce","iterator","iterable","Symbol","index","element","resolve","Promise","reject","pSeries","results","newInputs","lastInputs","i","initial","inputs","getResult","committed","React","isInputMatch","Boolean","areInputsEqual","cache","simpleProduce","createSimpleProduce","runActionReducerAtPath","actionReducer","reducerForActions","_aRD","reducerForCustomReducers","original","rootReducer","stateAfterActions","_cR","state","_cP","bindComputedProperty","parentState","noopStorage","getItem","setItem","removeItem","getBrowerStorage","window","storageCache","localStorage","sessionStorage","transformers","storage","console","outTransformers","serialize","data","cur","deserialize","JSON","isAsync","isPromise","wrapped","persistdef","config","allow","deny","mergeStrategy","createStorageWrapper","targets","_r","persistKey","persistPromise","isPersisting","timingMethod","operation","persistRootState","clone","persistTargets","resolvePersistTargets","stateToPersist","targetPath","rawValue","nextPersistOperation","clear","createPersistenceClearer","flush","getState","persistor","rehydrating","persistInstance","root","hasDataModelChanged","dataModel","rehydratingModelData","Array","applyRehydrationStrategy","set","targetState","persistedState","setAt","currentTargetState","currentPersistedState","rehydate","getItemResult","replaceState","type","def","payload","actionCreator","helpers","dispatch","fail","getStoreActions","getStoreState","injections","meta","logThunkEventListenerError","handleEventDispatchErrors","dispatcher","dispatchStart","dispatchFail","error","dispatchSuccess","failure","sourceAction","listenerdefs","targetTypes","_aCD","listenerReg","_lAM","runOnce","prevInputs","configurable","enumerable","resolver","prevValue","prevState","nextState","prevLocal","nextLocal","prevDependencies","nextDependencies","hasChanged","dependency","logEffectError","actions","dispose","disposeResult","effectResult","logEffectEventListenerError","change","prev","effectHandler","_dS","_aC","actionThunks","_e","_lAC","_persistenceConfig","_cS","isInReducer","recursiveExtractFromModel","handleValueAsState","initialParentRef","extractPersistConfig","category","actionName","createActionCreator","startType","successType","failType","createThunkHandler","createThunkActionsCreator","createComputedPropertyBinder","createEffectHandler","createEffectActionsCreator","existing","aPath","a","bPath","b","bindListenerdefs","options","modelClone","compose","devTools","enhancers","initialState","middleware","mockActions","storeName","version","reducerEnhancer","bindReplaceState","ePRS","modeldef","mockedActions","createPersistor","persistMiddleware","createPersistMiddleware","bindStoreInternals","extractDataFromModel","createReducer","mockActionsMiddleware","composeEnhancers","name","easyPeasyMiddleware","createComputedPropertiesMiddleware","createListenerMiddleware","createEffectsMiddleware","reduxCreateStore","applyMiddleware","bindActionCreators","rebindStore","currentState","resolveRehydration","rehydrateStateFromPersistIfNeeded","addModel","addModelRehydration","clearMockedActions","getActions","getListeners","getMockedActions","reconfigure","removeModel","mutableInjections","children","runtimeModel","nextInjections","nextKeys","removeKeys","useMemoOne","createStore","model","originalInjections","Provider","whitelist","blacklist","in","whitelistBlacklistCheck","inbound","out","outbound","dependencies","storeRef","configRef","previousState","configCreator","_store","modelCreator","setCurrentState"],"mappings":"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","sourcesContent":["import { createContext } from 'react';\n\nconst StoreContext = createContext();\n\nexport default StoreContext;\n","import {\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useReducer,\n  useRef,\n  useState,\n} from 'react';\nimport EasyPeasyContext from './context';\n\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\n// subscription callback always has the selector from the latest render commit\n// available, otherwise a store update may happen between render and the effect,\n// which may cause missed updates; we also must ensure the store subscription\n// is created synchronously, otherwise a store update may occur before the\n// subscription is created and an inconsistent state may be observed\nconst useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n\nexport function createStoreStateHook(Context) {\n  return function useStoreState(mapState, equalityFn) {\n    const store = useContext(Context);\n    const mapStateRef = useRef(mapState);\n    const stateRef = useRef();\n    const mountedRef = useRef(true);\n    const subscriptionMapStateError = useRef();\n\n    const [, forceRender] = useReducer((s) => s + 1, 0);\n\n    if (\n      subscriptionMapStateError.current ||\n      mapStateRef.current !== mapState ||\n      stateRef.current === undefined\n    ) {\n      try {\n        stateRef.current = mapState(store.getState());\n      } catch (err) {\n        if (process.env.NODE_ENV === 'development') {\n          let errorMessage = `Error in useStoreState: ${err.message}.`;\n          if (subscriptionMapStateError.current) {\n            errorMessage += `\\nMaybe related to:\\n${subscriptionMapStateError.current.stack}`;\n          }\n          throw new Error(errorMessage);\n        }\n        throw subscriptionMapStateError.current || err;\n      }\n    }\n\n    useIsomorphicLayoutEffect(() => {\n      mapStateRef.current = mapState;\n      subscriptionMapStateError.current = undefined;\n    });\n\n    useIsomorphicLayoutEffect(() => {\n      const checkMapState = () => {\n        try {\n          const newState = mapStateRef.current(store.getState());\n\n          const isStateEqual =\n            typeof equalityFn === 'function'\n              ? equalityFn(stateRef.current, newState)\n              : stateRef.current === newState;\n\n          if (isStateEqual) {\n            return;\n          }\n\n          stateRef.current = newState;\n        } catch (err) {\n          // see https://github.com/reduxjs/react-redux/issues/1179\n          // There is a possibility mapState will fail due to stale state or\n          // props, therefore we will just track the error and force our\n          // component to update. It should then receive the updated state\n          subscriptionMapStateError.current = err;\n        }\n        if (mountedRef.current) {\n          forceRender({});\n        }\n      };\n      const unsubscribe = store.subscribe(checkMapState);\n      checkMapState();\n      return () => {\n        mountedRef.current = false;\n        unsubscribe();\n      };\n    }, []);\n\n    return stateRef.current;\n  };\n}\n\nexport const useStoreState = createStoreStateHook(EasyPeasyContext);\n\nexport function createStoreActionsHook(Context) {\n  return function useStoreActions(mapActions) {\n    const store = useContext(Context);\n    return mapActions(store.getActions());\n  };\n}\n\nexport const useStoreActions = createStoreActionsHook(EasyPeasyContext);\n\nexport function createStoreDispatchHook(Context) {\n  return function useStoreDispatch() {\n    const store = useContext(Context);\n    return store.dispatch;\n  };\n}\n\nexport const useStoreDispatch = createStoreDispatchHook(EasyPeasyContext);\n\nexport function useStore() {\n  return useContext(EasyPeasyContext);\n}\n\nexport function createStoreRehydratedHook(Context) {\n  return function useStoreRehydrated() {\n    const store = useContext(Context);\n    const [rehydrated, setRehydrated] = useState(false);\n    useEffect(() => {\n      store.persist.resolveRehydration().then(() => setRehydrated(true));\n    }, []);\n    return rehydrated;\n  };\n}\n\nexport const useStoreRehydrated = createStoreRehydratedHook(EasyPeasyContext);\n\nexport function createTypedHooks() {\n  return {\n    useStoreActions,\n    useStoreDispatch,\n    useStoreState,\n    useStoreRehydrated,\n    useStore,\n  };\n}\n","export const actionSymbol = '$_a';\nexport const actionOnSymbol = '$_aO';\nexport const computedSymbol = '$_c';\nexport const effectOnSymbol = '$_e';\nexport const persistSymbol = '$_p';\nexport const reducerSymbol = '$_r';\nexport const thunkOnSymbol = '$_tO';\nexport const thunkSymbol = '$_t';\n","import { isDraft, current } from 'immer';\nimport {\n  actionOnSymbol,\n  actionSymbol,\n  computedSymbol,\n  effectOnSymbol,\n  persistSymbol,\n  reducerSymbol,\n  thunkOnSymbol,\n  thunkSymbol,\n} from './constants';\n\nexport const debug = (state) => {\n  if (isDraft(state)) {\n    return current(state);\n  }\n  return state;\n};\n\nexport const actionOn = (targetResolver, fn) => ({\n  [actionOnSymbol]: true,\n  fn,\n  targetResolver,\n});\n\nexport const action = (fn) => ({\n  [actionSymbol]: true,\n  fn,\n});\n\nconst defaultStateResolvers = [(state) => state];\n\nexport const computed = (fnOrStateResolvers, fn) => {\n  if (typeof fn === 'function') {\n    return {\n      [computedSymbol]: true,\n      fn,\n      stateResolvers: fnOrStateResolvers,\n    };\n  }\n  return {\n    [computedSymbol]: true,\n    fn: fnOrStateResolvers,\n    stateResolvers: defaultStateResolvers,\n  };\n};\n\nexport function unstable_effectOn(dependencyResolvers, fn) {\n  return {\n    [effectOnSymbol]: true,\n    dependencyResolvers,\n    fn,\n  };\n}\n\nexport function generic(value) {\n  return value;\n}\n\nexport const persist = (model, config) =>\n  // if we are not running in a browser context this becomes a no-op\n  typeof window === 'undefined'\n    ? model\n    : {\n        ...model,\n        [persistSymbol]: config,\n      };\n\nexport const thunkOn = (targetResolver, fn) => ({\n  [thunkOnSymbol]: true,\n  fn,\n  targetResolver,\n});\n\nexport const thunk = (fn) => ({\n  [thunkSymbol]: true,\n  fn,\n});\n\nexport const reducer = (fn) => ({\n  [reducerSymbol]: true,\n  fn,\n});\n","import React from 'react';\nimport { Immer, isDraft } from 'immer';\n\n/**\n * We create our own immer instance to avoid potential issues with autoFreeze\n * becoming default enabled everywhere. We want to disable autofreeze as it\n * does not suit the design of Easy Peasy.\n * https://github.com/immerjs/immer/issues/681#issuecomment-705581111\n */\nlet easyPeasyImmer;\n\nexport function isPlainObject(obj) {\n  if (typeof obj !== 'object' || obj === null) return false;\n\n  let proto = obj;\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(obj) === proto;\n}\n\nexport function clone(source) {\n  function recursiveClone(current) {\n    const next = Object.keys(current).reduce((acc, key) => {\n      if (Object.getOwnPropertyDescriptor(current, key).get == null) {\n        acc[key] = current[key];\n      }\n      return acc;\n    }, {});\n    Object.keys(next).forEach((key) => {\n      if (isPlainObject(next[key])) {\n        next[key] = recursiveClone(next[key]);\n      }\n    });\n    return next;\n  }\n  return recursiveClone(source);\n}\n\nexport function isPromise(x) {\n  return x != null && typeof x === 'object' && typeof x.then === 'function';\n}\n\nexport function get(path, target) {\n  return path.reduce(\n    (acc, cur) => (isPlainObject(acc) ? acc[cur] : undefined),\n    target,\n  );\n}\n\nexport function newify(currentPath, currentState, finalValue) {\n  if (currentPath.length === 0) {\n    return finalValue;\n  }\n  const newState = { ...currentState };\n  const key = currentPath[0];\n  if (currentPath.length === 1) {\n    newState[key] = finalValue;\n  } else {\n    newState[key] = newify(currentPath.slice(1), newState[key], finalValue);\n  }\n  return newState;\n}\n\nexport function set(path, target, value) {\n  if (path.length === 0) {\n    if (typeof value === 'object') {\n      Object.keys(target).forEach((key) => {\n        delete target[key];\n      });\n      Object.keys(value).forEach((key) => {\n        target[key] = value[key];\n      });\n    }\n    return;\n  }\n  path.reduce((acc, cur, idx) => {\n    if (idx + 1 === path.length) {\n      acc[cur] = value;\n    } else {\n      acc[cur] = acc[cur] || {};\n    }\n    return acc[cur];\n  }, target);\n}\n\nexport function createSimpleProduce(disableImmer = false) {\n  return function simpleProduce(path, state, fn) {\n    if (disableImmer) {\n      const current = get(path, state);\n      const next = fn(current);\n      if (current !== next) {\n        return newify(path, state, next);\n      }\n      return state;\n    }\n    if (!easyPeasyImmer) {\n      easyPeasyImmer = new Immer({\n        // We need to ensure that we disable proxies if they aren't available\n        // on the environment. Users need to ensure that they use the enableES5\n        // feature of immer.\n        useProxies:\n          typeof Proxy !== 'undefined' &&\n          typeof Proxy.revocable !== 'undefined' &&\n          typeof Reflect !== 'undefined',\n        // Autofreezing breaks easy-peasy, we need a mixed version of immutability\n        // and mutability in order to apply updates to our computed properties\n        autoFreeze: false,\n      });\n    }\n    if (path.length === 0) {\n      const draft = easyPeasyImmer.createDraft(state);\n      const result = fn(draft);\n      if (result) {\n        return isDraft(result) ? easyPeasyImmer.finishDraft(result) : result;\n      }\n      return easyPeasyImmer.finishDraft(draft);\n    }\n    const parentPath = path.slice(0, path.length - 1);\n    const draft = easyPeasyImmer.createDraft(state);\n    const parent = get(parentPath, state);\n    const current = get(path, draft);\n    const result = fn(current);\n\n    if (result) {\n      parent[path[path.length - 1]] = result;\n    }\n    return easyPeasyImmer.finishDraft(draft);\n  };\n}\n\nconst pReduce = (iterable, reducer, initialValue) =>\n  new Promise((resolve, reject) => {\n    const iterator = iterable[Symbol.iterator]();\n    let index = 0;\n\n    const next = (total) => {\n      const element = iterator.next();\n\n      if (element.done) {\n        resolve(total);\n        return;\n      }\n\n      Promise.all([total, element.value])\n        .then((value) =>\n          // eslint-disable-next-line no-plusplus\n          next(reducer(value[0], value[1], index++)),\n        )\n        .catch((err) => reject(err));\n    };\n\n    next(initialValue);\n  });\n\nexport const pSeries = (tasks) => {\n  const results = [];\n  return pReduce(tasks, (_, task) =>\n    task().then((value) => {\n      results.push(value);\n    }),\n  ).then(() => results);\n};\n\nexport function areInputsEqual(newInputs, lastInputs) {\n  if (newInputs.length !== lastInputs.length) {\n    return false;\n  }\n  for (let i = 0; i < newInputs.length; i += 1) {\n    if (newInputs[i] !== lastInputs[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// export function memoizeOne(resultFn) {\n//   let lastArgs = [];\n//   let lastResult;\n//   let calledOnce = false;\n\n//   return function memoized(...args) {\n//     if (calledOnce && areInputsEqual(args, lastArgs)) {\n//       return lastResult;\n//     }\n//     lastResult = resultFn(...args);\n//     calledOnce = true;\n//     lastArgs = args;\n//     return lastResult;\n//   };\n// }\n\nexport function useMemoOne(\n  // getResult changes on every call,\n  getResult,\n  // the inputs array changes on every call\n  inputs,\n) {\n  // using useState to generate initial value as it is lazy\n  const initial = React.useState(() => ({\n    inputs,\n    result: getResult(),\n  }))[0];\n\n  const committed = React.useRef(initial);\n\n  // persist any uncommitted changes after they have been committed\n\n  const isInputMatch = Boolean(\n    inputs &&\n      committed.current.inputs &&\n      areInputsEqual(inputs, committed.current.inputs),\n  );\n\n  // create a new cache if required\n  const cache = isInputMatch\n    ? committed.current\n    : {\n        inputs,\n        result: getResult(),\n      };\n\n  // commit the cache\n  React.useEffect(() => {\n    committed.current = cache;\n  }, [cache]);\n\n  return cache.result;\n}\n","import { isDraft, original } from 'immer';\nimport { createSimpleProduce, get } from './lib';\n\nexport default function createReducer(disableImmer, _aRD, _cR, _cP) {\n  const simpleProduce = createSimpleProduce(disableImmer);\n\n  const runActionReducerAtPath = (state, action, actionReducer, path) =>\n    simpleProduce(path, state, (draft) => actionReducer(draft, action.payload));\n\n  const reducerForActions = (state, action) => {\n    const actionReducer = _aRD[action.type];\n    if (actionReducer) {\n      return runActionReducerAtPath(\n        state,\n        action,\n        actionReducer,\n        actionReducer.def.meta.parent,\n      );\n    }\n    return state;\n  };\n\n  const reducerForCustomReducers = (state, action) =>\n    _cR.reduce(\n      (acc, { parentPath, key, reducer }) =>\n        simpleProduce(parentPath, acc, (draft) => {\n          draft[key] = reducer(\n            isDraft(draft[key]) ? original(draft[key]) : draft[key],\n            action,\n          );\n          return draft;\n        }),\n      state,\n    );\n\n  const rootReducer = (state, action) => {\n    const stateAfterActions = reducerForActions(state, action);\n    const next =\n      _cR.length > 0\n        ? reducerForCustomReducers(stateAfterActions, action)\n        : stateAfterActions;\n    if (state !== next) {\n      _cP.forEach(({ parentPath, bindComputedProperty }) => {\n        const parentState = get(parentPath, next);\n        if (parentState != null) bindComputedProperty(parentState, next);\n      });\n    }\n    return next;\n  };\n\n  return rootReducer;\n}\n","import { clone, get, isPlainObject, isPromise, set, pSeries } from './lib';\n\nconst noopStorage = {\n  getItem: () => undefined,\n  setItem: () => undefined,\n  removeItem: () => undefined,\n};\n\nconst getBrowerStorage = (storageName) => {\n  let storageCache;\n  return () => {\n    if (!storageCache) {\n      try {\n        if (\n          typeof window !== 'undefined' &&\n          typeof window[storageName] !== 'undefined'\n        ) {\n          storageCache = window[storageName];\n        }\n      } catch (_) {\n        // swallow the failure\n      }\n      if (!storageCache) {\n        storageCache = noopStorage;\n      }\n    }\n\n    return storageCache;\n  };\n};\n\nconst localStorage = getBrowerStorage('localStorage');\nconst sessionStorage = getBrowerStorage('sessionStorage');\n\nfunction createStorageWrapper(storage, transformers = []) {\n  if (storage == null) {\n    storage = sessionStorage();\n  }\n\n  if (typeof storage === 'string') {\n    if (storage === 'localStorage') {\n      storage = localStorage();\n    } else if (storage === 'sessionStorage') {\n      storage = sessionStorage();\n    } else {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(`Invalid storage provider`);\n      }\n      storage = noopStorage;\n    }\n  }\n\n  const outTransformers = [...transformers].reverse();\n\n  const serialize = (data) => {\n    if (transformers.length > 0 && data != null && typeof data === 'object') {\n      Object.keys(data).forEach((key) => {\n        data[key] = transformers.reduce(\n          (acc, cur) => cur.in(acc, key),\n          data[key],\n        );\n      });\n    }\n\n    return storage === localStorage() || storage === sessionStorage()\n      ? JSON.stringify({ data })\n      : data;\n  };\n\n  const deserialize = (data) => {\n    const result =\n      storage === localStorage() || storage === sessionStorage()\n        ? JSON.parse(data).data\n        : data;\n    if (\n      outTransformers.length > 0 &&\n      result != null &&\n      typeof result === 'object'\n    ) {\n      Object.keys(result).forEach((key) => {\n        result[key] = outTransformers.reduce(\n          (acc, cur) => cur.out(acc, key),\n          result[key],\n        );\n      });\n    }\n    return result;\n  };\n\n  const isAsync = isPromise(storage.getItem('_'));\n\n  return {\n    getItem: (key) => {\n      if (isAsync) {\n        return storage\n          .getItem(key)\n          .then((wrapped) =>\n            wrapped != null ? deserialize(wrapped) : undefined,\n          );\n      }\n      const wrapped = storage.getItem(key);\n      return wrapped != null ? deserialize(wrapped) : undefined;\n    },\n    setItem: (key, data) => storage.setItem(key, serialize(data)),\n    removeItem: (key) => storage.removeItem(key),\n  };\n}\n\nexport function extractPersistConfig(path, persistdef = {}) {\n  return {\n    path,\n    config: {\n      allow: persistdef.allow || [],\n      deny: persistdef.deny || [],\n      mergeStrategy: persistdef.mergeStrategy || 'mergeDeep',\n      storage: createStorageWrapper(\n        persistdef.storage,\n        persistdef.transformers,\n      ),\n    },\n  };\n}\n\nfunction resolvePersistTargets(target, allow, deny) {\n  let targets = Object.keys(target);\n  if (allow.length > 0) {\n    targets = targets.reduce((acc, cur) => {\n      if (allow.findIndex((x) => x === cur) !== -1) {\n        return [...acc, cur];\n      }\n      return acc;\n    }, []);\n  }\n  if (deny.length > 0) {\n    targets = targets.reduce((acc, cur) => {\n      if (deny.findIndex((x) => x === cur) !== -1) {\n        return acc;\n      }\n      return [...acc, cur];\n    }, []);\n  }\n  return targets;\n}\n\nfunction createPersistenceClearer(persistKey, _r) {\n  return () => {\n    if (_r._i._persistenceConfig.length === 0) {\n      return Promise.resolve();\n    }\n    return pSeries(\n      _r._i._persistenceConfig.map(({ path, config }) => () =>\n        Promise.resolve(config.storage.removeItem(persistKey(path))),\n      ),\n    );\n  };\n}\n\nexport function createPersistor(persistKey, _r) {\n  let persistPromise = Promise.resolve();\n  let isPersisting = false;\n  let nextPersistOperation;\n\n  const timingMethod =\n    typeof window === 'undefined'\n      ? (fn) => fn()\n      : window.requestIdleCallback != null\n      ? window.requestIdleCallback\n      : window.requestAnimationFrame;\n\n  const persist = (nextState) => {\n    if (_r._i._persistenceConfig.length === 0) {\n      return;\n    }\n\n    const operation = () => {\n      isPersisting = true;\n      persistPromise = new Promise((resolve) => {\n        timingMethod(() => {\n          pSeries(\n            _r._i._persistenceConfig.map(({ path, config }) => () => {\n              const { storage, allow, deny } = config;\n              const persistRootState = clone(get(path, nextState));\n              const persistTargets = resolvePersistTargets(\n                persistRootState,\n                allow,\n                deny,\n              );\n              const stateToPersist = {};\n              persistTargets.map((key) => {\n                const targetPath = [...path, key];\n                const rawValue = get(targetPath, nextState);\n                const value = isPlainObject(rawValue)\n                  ? clone(rawValue)\n                  : rawValue;\n                stateToPersist[key] = value;\n              });\n              return Promise.resolve(\n                storage.setItem(persistKey(path), stateToPersist),\n              );\n            }),\n          ).finally(() => {\n            isPersisting = false;\n            if (nextPersistOperation) {\n              const next = nextPersistOperation;\n              nextPersistOperation = null;\n              next();\n            } else {\n              resolve();\n            }\n          });\n        });\n      });\n    };\n\n    if (isPersisting) {\n      nextPersistOperation = operation;\n    } else {\n      operation();\n    }\n  };\n\n  return {\n    persist,\n    clear: createPersistenceClearer(persistKey, _r),\n    flush: () => {\n      if (nextPersistOperation) {\n        nextPersistOperation();\n      }\n      return persistPromise;\n    },\n  };\n}\n\nexport function createPersistMiddleware(persistor, _r) {\n  return ({ getState }) => (next) => (action) => {\n    const state = next(action);\n    if (\n      action &&\n      action.type !== '@action.ePRS' &&\n      _r._i._persistenceConfig.length > 0\n    ) {\n      persistor.persist(getState());\n    }\n    return state;\n  };\n}\n\nexport function rehydrateStateFromPersistIfNeeded(\n  persistKey,\n  replaceState,\n  _r,\n  root,\n) {\n  if (_r._i._persistenceConfig.length === 0) {\n    return Promise.resolve();\n  }\n\n  const state = clone(_r._i._dS);\n\n  let rehydrating = false;\n\n  return pSeries(\n    _r._i._persistenceConfig.map((persistInstance) => () => {\n      const { path, config } = persistInstance;\n      const { mergeStrategy, storage } = config;\n\n      if (root && (path.length < 1 || path[0] !== root)) {\n        return Promise.resolve();\n      }\n\n      const hasDataModelChanged = (dataModel, rehydratingModelData) =>\n        dataModel != null &&\n        rehydratingModelData != null &&\n        (typeof dataModel !== typeof rehydratingModelData ||\n          (Array.isArray(dataModel) && !Array.isArray(rehydratingModelData)));\n\n      const applyRehydrationStrategy = (persistedState) => {\n        if (mergeStrategy === 'overwrite') {\n          set(path, state, persistedState);\n        } else if (mergeStrategy === 'mergeShallow') {\n          const targetState = get(path, state);\n          Object.keys(persistedState).forEach((key) => {\n            if (hasDataModelChanged(targetState[key], persistedState[key])) {\n              // skip as the data model type has changed since the data was persisted\n            } else {\n              targetState[key] = persistedState[key];\n            }\n          });\n        } else if (mergeStrategy === 'mergeDeep') {\n          const targetState = get(path, state);\n          const setAt = (currentTargetState, currentPersistedState) => {\n            Object.keys(currentPersistedState).forEach((key) => {\n              if (\n                hasDataModelChanged(\n                  currentTargetState[key],\n                  currentPersistedState[key],\n                )\n              ) {\n                // skip as the data model type has changed since the data was persisted\n              } else if (isPlainObject(currentPersistedState[key])) {\n                currentTargetState[key] = currentTargetState[key] || {};\n                setAt(currentTargetState[key], currentPersistedState[key]);\n              } else {\n                currentTargetState[key] = currentPersistedState[key];\n              }\n            });\n          };\n          setAt(targetState, persistedState);\n        }\n      };\n\n      const rehydate = (persistedState) => {\n        if (persistedState != null) {\n          applyRehydrationStrategy(persistedState);\n          rehydrating = true;\n        }\n      };\n\n      const getItemResult = storage.getItem(persistKey(path));\n      if (isPromise(getItemResult)) {\n        return getItemResult.then(rehydate);\n      }\n      return Promise.resolve(rehydate(getItemResult));\n    }),\n  ).then(() => {\n    if (rehydrating) {\n      replaceState(state);\n    }\n  });\n}\n","import { actionOnSymbol } from './constants';\n\nexport function createActionCreator(def, _r) {\n  function actionCreator(payload) {\n    const action = {\n      type: def.meta.type,\n      payload,\n    };\n    if (def[actionOnSymbol] && def.meta.resolvedTargets) {\n      payload.resolvedTargets = [...def.meta.resolvedTargets];\n    }\n    return _r.dispatch(action);\n  }\n\n  // We bind the types to the creator for easy reference by consumers\n  actionCreator.type = def.meta.type;\n\n  return actionCreator;\n}\n","import { thunkOnSymbol } from './constants';\nimport { get, isPromise } from './lib';\n\nexport function createThunkHandler(def, _r, injections, _aC) {\n  return (payload, fail) => {\n    const helpers = {\n      dispatch: _r.dispatch,\n      fail,\n      getState: () => get(def.meta.parent, _r.getState()),\n      getStoreActions: () => _aC,\n      getStoreState: _r.getState,\n      injections,\n      meta: {\n        key: def.meta.actionName,\n        parent: def.meta.parent,\n        path: def.meta.path,\n      },\n    };\n    if (def[thunkOnSymbol] && def.meta.resolvedTargets) {\n      payload.resolvedTargets = [...def.meta.resolvedTargets];\n    }\n    return def.fn(get(def.meta.parent, _aC), payload, helpers);\n  };\n}\n\nconst logThunkEventListenerError = (type, err) => {\n  // eslint-disable-next-line no-console\n  console.log(`Error in ${type}`);\n  // eslint-disable-next-line no-console\n  console.log(err);\n};\n\nconst handleEventDispatchErrors = (type, dispatcher) => (...args) => {\n  try {\n    const result = dispatcher(...args);\n    if (isPromise(result)) {\n      result.catch((err) => {\n        logThunkEventListenerError(type, err);\n      });\n    }\n  } catch (err) {\n    logThunkEventListenerError(type, err);\n  }\n};\n\nexport function createThunkActionsCreator(def, _r) {\n  const actionCreator = (payload) => {\n    const dispatchStart = handleEventDispatchErrors(def.meta.startType, () =>\n      _r.dispatch({\n        type: def.meta.startType,\n        payload,\n      }),\n    );\n\n    const dispatchFail = handleEventDispatchErrors(def.meta.failType, (err) =>\n      _r.dispatch({\n        type: def.meta.failType,\n        payload,\n        error: err,\n      }),\n    );\n\n    const dispatchSuccess = handleEventDispatchErrors(\n      def.meta.successType,\n      (result) =>\n        _r.dispatch({\n          type: def.meta.successType,\n          payload,\n          result,\n        }),\n    );\n\n    dispatchStart();\n\n    let failure = null;\n\n    const fail = (_failure) => {\n      failure = _failure;\n    };\n\n    const result = _r.dispatch(() => def.thunkHandler(payload, fail));\n\n    if (isPromise(result)) {\n      return result.then((resolved) => {\n        if (failure) {\n          dispatchFail(failure);\n        } else {\n          dispatchSuccess(resolved);\n        }\n        return resolved;\n      });\n    }\n\n    if (failure) {\n      dispatchFail(failure);\n    } else {\n      dispatchSuccess(result);\n    }\n\n    return result;\n  };\n\n  actionCreator.type = def.meta.type;\n  actionCreator.successType = def.meta.successType;\n  actionCreator.failType = def.meta.failType;\n  actionCreator.startType = def.meta.startType;\n\n  return actionCreator;\n}\n","import { get } from './lib';\n\nexport function createListenerMiddleware(_r) {\n  return () => (next) => (action) => {\n    const result = next(action);\n    if (\n      action &&\n      _r._i._lAM[action.type] &&\n      _r._i._lAM[action.type].length > 0\n    ) {\n      const sourceAction = _r._i._aCD[action.type];\n      _r._i._lAM[action.type].forEach((actionCreator) => {\n        actionCreator({\n          type: sourceAction ? sourceAction.def.meta.type : action.type,\n          payload: action.payload,\n          error: action.error,\n          result: action.result,\n        });\n      });\n    }\n    return result;\n  };\n}\n\nexport function bindListenerdefs(listenerdefs, _aC, _aCD, _lAM) {\n  listenerdefs.forEach((def) => {\n    const targets = def.targetResolver(get(def.meta.parent, _aC), _aC);\n\n    const targetTypes = (Array.isArray(targets) ? targets : [targets]).reduce(\n      (acc, target) => {\n        if (\n          typeof target === 'function' &&\n          target.def.meta.type &&\n          _aCD[target.def.meta.type]\n        ) {\n          if (target.def.meta.successType) {\n            acc.push(target.def.meta.successType);\n          } else {\n            acc.push(target.def.meta.type);\n          }\n        } else if (typeof target === 'string') {\n          acc.push(target);\n        }\n        return acc;\n      },\n      [],\n    );\n\n    def.meta.resolvedTargets = targetTypes;\n\n    targetTypes.forEach((targetType) => {\n      const listenerReg = _lAM[targetType] || [];\n      listenerReg.push(_aCD[def.meta.type]);\n      _lAM[targetType] = listenerReg;\n    });\n  });\n}\n","import { areInputsEqual } from './lib';\n\nexport function createComputedPropertyBinder(parentPath, key, def, _r) {\n  let runOnce = false;\n  let prevInputs = [];\n  let prevValue;\n  return function createComputedProperty(parentState, storeState) {\n    Object.defineProperty(parentState, key, {\n      configurable: true,\n      enumerable: true,\n      get: () => {\n        const inputs = def.stateResolvers.map((resolver) =>\n          resolver(parentState, storeState),\n        );\n        if (\n          runOnce &&\n          (areInputsEqual(prevInputs, inputs) ||\n            (_r._i._cS.isInReducer &&\n              new Error().stack.match(/shallowCopy/gi) !== null))\n        ) {\n          // We don't want computed properties resolved every time an action\n          // is handled by the reducer. They need to remain lazy, only being\n          // computed when used by a component or getState call.\n          return prevValue;\n        }\n        prevInputs = inputs;\n        prevValue = def.fn(...inputs);\n        runOnce = true;\n        return prevValue;\n      },\n    });\n  };\n}\n\nexport function createComputedPropertiesMiddleware(_r) {\n  return () => (next) => (action) => {\n    _r._i._cS.isInReducer = true;\n    const result = next(action);\n    _r._i._cS.isInReducer = false;\n    return result;\n  };\n}\n","import { get, isPromise } from './lib';\n\nexport function createEffectsMiddleware(_r) {\n  return (store) => (next) => (action) => {\n    if (_r._i._e.length === 0) {\n      return next(action);\n    }\n    const prevState = store.getState();\n    const result = next(action);\n    const nextState = store.getState();\n    _r._i._e.forEach((def) => {\n      const prevLocal = get(def.meta.parent, prevState);\n      const nextLocal = get(def.meta.parent, nextState);\n      if (prevLocal !== nextLocal) {\n        const prevDependencies = def.dependencyResolvers.map((resolver) =>\n          resolver(prevLocal),\n        );\n        const nextDependencies = def.dependencyResolvers.map((resolver) =>\n          resolver(nextLocal),\n        );\n        const hasChanged = prevDependencies.some(\n          (dependency, idx) => dependency !== nextDependencies[idx],\n        );\n        if (hasChanged) {\n          def.actionCreator(prevDependencies, nextDependencies, action);\n        }\n      }\n    });\n    return result;\n  };\n}\n\nconst logEffectError = (err) => {\n  // As users can't get a handle on effects we need to report the error\n  // eslint-disable-next-line no-console\n  console.log(err);\n};\n\nexport function createEffectHandler(def, _r, injections, _aC) {\n  const actions = get(def.meta.parent, _aC);\n\n  let dispose;\n\n  return (change) => {\n    const helpers = {\n      dispatch: _r.dispatch,\n      getState: () => get(def.meta.parent, _r.getState()),\n      getStoreActions: () => _aC,\n      getStoreState: _r.getState,\n      injections,\n      meta: {\n        key: def.meta.actionName,\n        parent: def.meta.parent,\n        path: def.meta.path,\n      },\n    };\n\n    if (dispose !== undefined) {\n      const disposeResult = dispose();\n      dispose = undefined;\n      if (isPromise(disposeResult)) {\n        disposeResult.catch(logEffectError);\n      }\n    }\n\n    const effectResult = def.fn(actions, change, helpers);\n\n    if (isPromise(effectResult)) {\n      return effectResult.then((resolved) => {\n        if (typeof resolved === 'function') {\n          if (process.env.NODE_ENV !== 'production') {\n            // Dispose functions are not allowed to be resolved asynchronously.\n            // Doing so would provide inconsistent behaviour around their execution.\n            // eslint-disable-next-line no-console\n            console.warn(\n              '[easy-peasy] Effect is asynchronously resolving a dispose fn.',\n            );\n          }\n        }\n      });\n    }\n\n    if (typeof effectResult === 'function') {\n      dispose = effectResult;\n    }\n\n    return undefined;\n  };\n}\n\nconst logEffectEventListenerError = (type, err) => {\n  // eslint-disable-next-line no-console\n  console.log(`Error in ${type}`);\n  // eslint-disable-next-line no-console\n  console.log(err);\n};\n\nconst handleEventDispatchErrors = (type, dispatcher) => (...args) => {\n  try {\n    const result = dispatcher(...args);\n    if (isPromise(result)) {\n      result.catch((err) => {\n        logEffectEventListenerError(type, err);\n      });\n    }\n  } catch (err) {\n    logEffectEventListenerError(type, err);\n  }\n};\n\nexport function createEffectActionsCreator(def, _r, effectHandler) {\n  const actionCreator = (previousDependencies, nextDependencies, action) => {\n    const change = {\n      prev: previousDependencies,\n      current: nextDependencies,\n      action,\n    };\n\n    const dispatchStart = handleEventDispatchErrors(def.meta.startType, () =>\n      _r.dispatch({\n        type: def.meta.startType,\n        change,\n      }),\n    );\n\n    const dispatchSuccess = handleEventDispatchErrors(\n      def.meta.successType,\n      () =>\n        _r.dispatch({\n          type: def.meta.successType,\n          change,\n        }),\n    );\n\n    dispatchStart();\n\n    try {\n      const result = _r.dispatch(() => effectHandler(change));\n\n      if (isPromise(result)) {\n        return result.then((resolved) => {\n          dispatchSuccess(resolved);\n          return resolved;\n        }, logEffectError);\n      }\n\n      dispatchSuccess(result);\n\n      return result;\n    } catch (err) {\n      logEffectError(err);\n    }\n  };\n\n  actionCreator.type = def.meta.type;\n  actionCreator.startType = def.meta.startType;\n  actionCreator.successType = def.meta.successType;\n  actionCreator.failType = def.meta.failType;\n\n  return actionCreator;\n}\n","import {\n  actionOnSymbol,\n  actionSymbol,\n  computedSymbol,\n  effectOnSymbol,\n  persistSymbol,\n  reducerSymbol,\n  thunkOnSymbol,\n  thunkSymbol,\n} from './constants';\nimport { get, isPlainObject, set } from './lib';\nimport { extractPersistConfig } from './persistence';\nimport { createActionCreator } from './actions';\nimport { createThunkHandler, createThunkActionsCreator } from './thunks';\nimport { bindListenerdefs } from './listeners';\nimport { createComputedPropertyBinder } from './computed-properties';\nimport { createEffectHandler, createEffectActionsCreator } from './effects';\n\nexport default function extractDataFromModel(\n  model,\n  initialState,\n  injections,\n  _r,\n) {\n  const _dS = initialState;\n  const _aCD = {};\n  const _aC = {};\n  const _aRD = {};\n  const actionThunks = {};\n  const _cP = [];\n  const _cR = [];\n  const _e = [];\n  const _lAC = {};\n  const _lAM = {};\n  const listenerdefs = [];\n  let _persistenceConfig = [];\n  const _cS = {\n    isInReducer: false,\n  };\n\n  const recursiveExtractFromModel = (current, parentPath) =>\n    Object.keys(current).forEach((key) => {\n      const value = current[key];\n      const path = [...parentPath, key];\n      const meta = {\n        parent: parentPath,\n        path,\n        key,\n      };\n      const handleValueAsState = () => {\n        const initialParentRef = get(parentPath, initialState);\n        if (initialParentRef && key in initialParentRef) {\n          set(path, _dS, initialParentRef[key]);\n        } else {\n          set(path, _dS, value);\n        }\n      };\n\n      if (key === persistSymbol) {\n        _persistenceConfig.push(extractPersistConfig(parentPath, value));\n        return;\n      }\n\n      if (value != null && typeof value === 'object') {\n        if (value[actionSymbol] || value[actionOnSymbol]) {\n          const def = { ...value };\n\n          // Determine the category of the action\n          const category = def[actionSymbol] ? '@action' : '@actionOn';\n\n          // Establish the meta data describing the action\n          def.meta = {\n            actionName: meta.key,\n            category,\n            type: `${category}.${meta.path.join('.')}`,\n            parent: meta.parent,\n            path: meta.path,\n          };\n\n          // Create the \"action creator\" function\n          def.actionCreator = createActionCreator(def, _r);\n\n          // Create a bidirectional relationship of the def/actionCreator\n          def.actionCreator.def = def;\n\n          // Create a bidirectional relationship of the def/reducer\n          def.fn.def = def;\n\n          // Add the action creator to lookup map\n          _aCD[def.meta.type] = def.actionCreator;\n\n          // Add the reducer to lookup map\n          _aRD[def.meta.type] = def.fn;\n\n          // We don't want to expose the internal action to consumers\n          if (meta.key !== 'ePRS') {\n            // Set the action creator in the \"actions\" object tree for\n            // either the listeners object tree, or the standard actions/thunks\n            // object tree\n            if (def[actionOnSymbol]) {\n              listenerdefs.push(def);\n              set(path, _lAC, def.actionCreator);\n            } else {\n              set(path, _aC, def.actionCreator);\n            }\n          }\n        } else if (value[thunkSymbol] || value[thunkOnSymbol]) {\n          const def = { ...value };\n\n          // Determine the category of the thunk\n          const category = def[thunkSymbol] ? '@thunk' : '@thunkOn';\n\n          // Establish the meta data describing the thunk\n          const type = `${category}.${meta.path.join('.')}`;\n          def.meta = {\n            actionName: meta.key,\n            parent: meta.parent,\n            path: meta.path,\n            type,\n            startType: `${type}(start)`,\n            successType: `${type}(success)`,\n            failType: `${type}(fail)`,\n          };\n\n          // Create the function that will handle, i.e. be executed, when\n          // the thunk action is created/dispatched\n          def.thunkHandler = createThunkHandler(def, _r, injections, _aC);\n\n          // Register the thunk handler\n          set(path, actionThunks, def.thunkHandler);\n\n          // Create the \"action creator\" function\n          def.actionCreator = createThunkActionsCreator(def, _r);\n\n          // Create a bidirectional relationship of the def/actionCreator\n          def.actionCreator.def = def;\n\n          // Register the action creator within the lookup map\n          _aCD[def.meta.type] = def.actionCreator;\n\n          // Set the action creator in the \"actions\" object tree for\n          // either the listeners object tree, or the standard actions/thunks\n          // object tree\n          if (def[thunkOnSymbol]) {\n            listenerdefs.push(def);\n            set(path, _lAC, def.actionCreator);\n          } else {\n            set(path, _aC, def.actionCreator);\n          }\n        } else if (value[computedSymbol]) {\n          const parent = get(parentPath, _dS);\n          const bindComputedProperty = createComputedPropertyBinder(\n            parentPath,\n            key,\n            value,\n            _r,\n          );\n          bindComputedProperty(parent, _dS);\n          _cP.push({ key, parentPath, bindComputedProperty });\n        } else if (value[reducerSymbol]) {\n          _cR.push({ key, parentPath, reducer: value.fn });\n        } else if (value[effectOnSymbol]) {\n          const def = { ...value };\n\n          // Establish the meta data describing the effect\n          const type = `@effectOn.${meta.path.join('.')}`;\n          def.meta = {\n            type,\n            actionName: meta.key,\n            parent: meta.parent,\n            path: meta.path,\n            startType: `${type}(start)`,\n            successType: `${type}(success)`,\n            failType: `${type}(fail)`,\n          };\n\n          const effectHandler = createEffectHandler(def, _r, injections, _aC);\n\n          const actionCreator = createEffectActionsCreator(\n            def,\n            _r,\n            effectHandler,\n          );\n\n          def.actionCreator = actionCreator;\n\n          _e.push(def);\n        } else if (isPlainObject(value)) {\n          const existing = get(path, _dS);\n          if (existing == null) {\n            set(path, _dS, {});\n          }\n          recursiveExtractFromModel(value, path);\n        } else {\n          handleValueAsState();\n        }\n      } else {\n        handleValueAsState();\n      }\n    });\n\n  _persistenceConfig = _persistenceConfig.sort((a, b) => {\n    const aPath = a.path.join('.');\n    const bPath = b.path.join('.');\n    if (aPath < bPath) {\n      return -1;\n    }\n    if (aPath > bPath) {\n      return 1;\n    }\n    return 0;\n  });\n\n  recursiveExtractFromModel(model, []);\n\n  bindListenerdefs(listenerdefs, _aC, _aCD, _lAM);\n\n  return {\n    _aCD,\n    _aC,\n    _aRD,\n    _cP,\n    _cR,\n    _cS,\n    _dS,\n    _e,\n    _lAC,\n    _lAM,\n    _persistenceConfig,\n  };\n}\n","import {\n  applyMiddleware,\n  compose as reduxCompose,\n  createStore as reduxCreateStore,\n} from 'redux';\nimport reduxThunk from 'redux-thunk';\nimport * as helpers from './helpers';\nimport createReducer from './create-reducer';\nimport extractDataFromModel from './extract-data-from-model';\nimport {\n  createPersistor,\n  createPersistMiddleware,\n  rehydrateStateFromPersistIfNeeded,\n} from './persistence';\nimport { createComputedPropertiesMiddleware } from './computed-properties';\nimport { createListenerMiddleware } from './listeners';\nimport { clone } from './lib';\nimport { createEffectsMiddleware } from './effects';\n\nexport function createStore(model, options = {}) {\n  const modelClone = clone(model);\n  const {\n    compose,\n    devTools = process.env.NODE_ENV !== 'production',\n    disableImmer = false,\n    enhancers = [],\n    initialState = {},\n    injections = {},\n    middleware = [],\n    mockActions = false,\n    name: storeName = `EasyPeasyStore`,\n    version = 0,\n    reducerEnhancer = (rootReducer) => rootReducer,\n  } = options;\n\n  const bindReplaceState = (modelDef) => ({\n    ...modelDef,\n    ePRS: helpers.action((_, payload) => payload),\n  });\n\n  const _r = {};\n\n  let modeldef = bindReplaceState(modelClone);\n  let mockedActions = [];\n\n  const persistKey = (targetPath) =>\n    `[${storeName}][${version}]${\n      targetPath.length > 0 ? `[${targetPath.join('.')}]` : ''\n    }`;\n  const persistor = createPersistor(persistKey, _r);\n  const persistMiddleware = createPersistMiddleware(persistor, _r);\n\n  const replaceState = (nextState) => _r._i._aCD['@action.ePRS'](nextState);\n\n  const bindStoreInternals = (state = {}) => {\n    const data = extractDataFromModel(modeldef, state, injections, _r);\n    _r._i = {\n      ...data,\n      reducer: reducerEnhancer(\n        createReducer(disableImmer, data._aRD, data._cR, data._cP),\n      ),\n    };\n  };\n\n  const mockActionsMiddleware = () => () => (action) => {\n    if (action != null) {\n      mockedActions.push(action);\n    }\n    return undefined;\n  };\n\n  const composeEnhancers =\n    compose ||\n    (devTools &&\n    typeof window !== 'undefined' &&\n    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\n      ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({\n          name: storeName,\n        })\n      : reduxCompose);\n\n  bindStoreInternals(initialState);\n\n  const easyPeasyMiddleware = [\n    createComputedPropertiesMiddleware(_r),\n    ...middleware,\n    reduxThunk,\n    createListenerMiddleware(_r),\n    createEffectsMiddleware(_r),\n    persistMiddleware,\n  ];\n\n  if (mockActions) {\n    easyPeasyMiddleware.push(mockActionsMiddleware);\n  }\n\n  const store = reduxCreateStore(\n    _r._i.reducer,\n    _r._i._dS,\n    composeEnhancers(applyMiddleware(...easyPeasyMiddleware), ...enhancers),\n  );\n\n  store.subscribe(() => {\n    _r._i._cS.isInReducer = false;\n  });\n\n  _r.dispatch = store.dispatch;\n  _r.getState = store.getState;\n\n  const bindActionCreators = () => {\n    Object.keys(store.dispatch).forEach((actionsKey) => {\n      delete store.dispatch[actionsKey];\n    });\n    Object.keys(_r._i._aC).forEach((key) => {\n      store.dispatch[key] = _r._i._aC[key];\n    });\n  };\n\n  bindActionCreators();\n\n  const rebindStore = (removeKey) => {\n    const currentState = store.getState();\n    if (removeKey) {\n      delete currentState[removeKey];\n    }\n    bindStoreInternals(currentState);\n    store.replaceReducer(_r._i.reducer);\n    replaceState(_r._i._dS);\n    bindActionCreators();\n  };\n\n  const resolveRehydration = rehydrateStateFromPersistIfNeeded(\n    persistKey,\n    replaceState,\n    _r,\n  );\n\n  return Object.assign(store, {\n    addModel: (key, modelForKey) => {\n      if (modeldef[key] && process.env.NODE_ENV !== 'production') {\n        store.removeModel(key);\n      }\n      modeldef[key] = modelForKey;\n      rebindStore();\n      // There may have been persisted state for a dynamic model. We should try\n      // and rehydrate the specifc node\n      const addModelRehydration = rehydrateStateFromPersistIfNeeded(\n        persistKey,\n        replaceState,\n        _r,\n        key,\n      );\n      return {\n        resolveRehydration: () => addModelRehydration,\n      };\n    },\n    clearMockedActions: () => {\n      mockedActions = [];\n    },\n    getActions: () => _r._i._aC,\n    getListeners: () => _r._i._lAC,\n    getMockedActions: () => [...mockedActions],\n    persist: {\n      clear: persistor.clear,\n      flush: persistor.flush,\n      resolveRehydration: () => resolveRehydration,\n    },\n    reconfigure: (newModel) => {\n      modeldef = bindReplaceState(newModel);\n      rebindStore();\n    },\n    removeModel: (key) => {\n      if (!modeldef[key]) {\n        return;\n      }\n      delete modeldef[key];\n      rebindStore(key);\n    },\n  });\n}\n","/* eslint-disable react/prop-types */\n\nimport React, { createContext, useContext } from 'react';\nimport {\n  createStoreActionsHook,\n  createStoreDispatchHook,\n  createStoreStateHook,\n  createStoreRehydratedHook,\n} from './hooks';\nimport { createStore } from './create-store';\nimport { useMemoOne } from './lib';\n\nexport function createContextStore(model, config = {}) {\n  // We create a mutable injections reference to allow updating it\n  const { injections: mutableInjections = {} } = config;\n\n  const StoreContext = createContext();\n\n  function Provider({ children, runtimeModel, injections }) {\n    // If the user provided injections we need to ensure our mutable ref\n    // is up to date. We could consider doing a shallow compare here?\n    if (injections != null) {\n      const nextInjections =\n        typeof injections === 'function'\n          ? injections(mutableInjections)\n          : injections;\n      const nextKeys = Object.keys(nextInjections);\n      const removeKeys = Object.keys(mutableInjections).filter(\n        (k) => !nextKeys.includes(k),\n      );\n      removeKeys.forEach((k) => {\n        delete mutableInjections[k];\n      });\n      Object.assign(mutableInjections, nextInjections);\n    }\n\n    const store = useMemoOne(\n      () =>\n        createStore(typeof model === 'function' ? model(runtimeModel) : model, {\n          ...config,\n          originalInjections: mutableInjections,\n        }),\n      [],\n    );\n    return (\n      <StoreContext.Provider value={store}>{children}</StoreContext.Provider>\n    );\n  }\n\n  function useStore() {\n    return useContext(StoreContext);\n  }\n\n  return {\n    Provider,\n    useStore,\n    useStoreState: createStoreStateHook(StoreContext),\n    useStoreActions: createStoreActionsHook(StoreContext),\n    useStoreDispatch: createStoreDispatchHook(StoreContext),\n    useStoreRehydrated: createStoreRehydratedHook(StoreContext),\n  };\n}\n","/**\n * This file has been copied from redux-persist.\n * The intention being to support as much of the redux-persist API as possible.\n */\n\nexport function createTransform(inbound, outbound, config = {}) {\n  const whitelist = config.whitelist || null;\n  const blacklist = config.blacklist || null;\n\n  function whitelistBlacklistCheck(key) {\n    if (whitelist && whitelist.indexOf(key) === -1) return true;\n    if (blacklist && blacklist.indexOf(key) !== -1) return true;\n    return false;\n  }\n\n  return {\n    in: (data, key, fullState) =>\n      !whitelistBlacklistCheck(key) && inbound\n        ? inbound(data, key, fullState)\n        : data,\n    out: (data, key, fullState) =>\n      !whitelistBlacklistCheck(key) && outbound\n        ? outbound(data, key, fullState)\n        : data,\n  };\n}\n","/* eslint-disable react/prop-types */\n\nimport React from 'react';\nimport StoreContext from './context';\n\nexport function StoreProvider({ children, store }) {\n  return (\n    <StoreContext.Provider value={store}>{children}</StoreContext.Provider>\n  );\n}\n","import { useEffect, useRef, useState } from 'react';\nimport { useMemoOne } from './lib';\nimport { createStore } from './create-store';\n\nexport function useLocalStore(modelCreator, dependencies = [], configCreator) {\n  const storeRef = useRef();\n\n  const configRef = useRef();\n\n  const store = useMemoOne(() => {\n    const previousState =\n      storeRef.current != null ? storeRef.current.getState() : undefined;\n    const config =\n      configCreator != null\n        ? configCreator(previousState, configRef.current)\n        : undefined;\n    const _store = createStore(modelCreator(previousState), config);\n    configRef.current = config;\n    storeRef.current = _store;\n    return _store;\n  }, dependencies);\n\n  const [currentState, setCurrentState] = useState(() => store.getState());\n\n  useEffect(\n    () =>\n      store.subscribe(() => {\n        const nextState = store.getState();\n        if (currentState !== nextState) {\n          setCurrentState(nextState);\n        }\n      }),\n    [store],\n  );\n\n  return [currentState, store.getActions(), store];\n}\n"]},"metadata":{},"sourceType":"module"}